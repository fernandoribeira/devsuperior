
- Algoritmo

	Sequência finita de instruções para se resolver um problema, aplicando-se a diversas áreas de conhecimento.

- Automação

	Consiste em utilizar uma máquina para executar o procedimento desejado de forma automática ou semiautomática.

- Computador

	Um computador é composto por:

	Hardware - parte física (as peças)
	Software - parte lógica (os programas)

- Programa de computador

	Programas de computador são algoritmos executados pelo computador.

	O computador é uma máquina que automatiza a execução de algoritmos.

	Porém funciona apenas para algoritmos computacionais como processamento de dados e cálculos.

- O que é preciso para se fazer um programa de computador

	Vamos precisar de:

	Uma linguagem de programação
	Uma IDE (Integrated Development Environment ou Ambiente de Desenvolvimento Integrado)
	Um compilador
	Um gerador de código ou máquina virtual

- Linguagem de programação


	É um conjunto de regras léxicas (ortografia) e sintáticas (gramática) para se escrever programas.

	Léxica diz respeito à correção das palavras "isoladas" (ortografia).

	Sintática diz respeito à correção das sentenças (gramática).

	Exemplos de linguagens de programação: C, Pascal, C++, Java, C#, Python, Ruby, PHP, JavaScript, etc.

- IDE

	IDE significa "Integrated Development Environment" ou traduzindo "Ambiente de Desenvolvimento Integrado".

	É um conjunto de softwares utilizado para a construção de programas, exemplos:

	C/C++ - Code Blocks
	Java -  Eclipse, NetBeans
	C# - Microsoft Visual Studio

	Funcionalidades de uma IDE:

	Edição de código fonte (endentação, autocompletar, destaque de palavras, etc.)
	Depuração e testes
	Construção do produto final
	Sugestão de modelos
	Auxiliar em várias tarefas do seu projeto

- Código fonte

	É aquele escrito pelo programador em linguagem de programação na construção dos programas.

- Modos de construção de programas

	Compilação
	Interpretação
	Abordagem híbrida

- Compilação

	cria o código fonte > passa pelo compilador (análise léxica e análise sintática) > que cria o código objeto > passa pelo gerador de código > que cria o código executavel específico > que é executado pelo S.O.

	Exemplos de linguagem: C, C++

- Interpretação

	cria o código fonte > passa pelo interpretador (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: PHP, JavaScript

- Abordagem híbrida

	cria o código fonte > passa pelo pré-compilador (análise léxica e análise sintática) > que cria o código Bytecode > passa pela máquina virtual (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: Java, C#

- Vantagens e desvantagens dos modos de construção de programas

	Compilação

	Vantagens: alta velocidade de execução do programa, auxilio do compilador na checagem do programa
	Desvantagens: necessidade de compilar para cada S.O., precisa ser recompilado caso seja alterado

	Interpretação

	Vantagens: não precisa compilar para cada S.O.
	Desvantagens: baixa velocidade de execução do programa, não temos auxilio do compilador na checagem do programa

	Abordagem híbrida

	Vantagens: não precisa compilar para cada S.O., auxilio do compilador na checagem do programa
	Desvantagens: média velocidade de execução do programa, precisa ser recompilado caso seja alterado

- Três operações básicas de programação

	Entrada de dados: normalmemnte feita pelo teclado ou mouse

	Processamento de dados: feita pelo processador

	Saída de dados: normalmente feito pelo monitor

- Java

	É uma linguagem de programação, plataforma de desenvolvimento e execução de programas.

	Criada pela Sun Microsystems no meio da década de 1990 e adquirida pela Oracle Corporation em 2010.

	Desenhada para ser utilizada em todos os tipos de dispositivos, principalmente portáteis.

	É uma linguagem orientada a objetos, segura, robusta e que domina o mercado a muitos anos.

	Resolve problemas de linguagens antigas como ponteiros / gerenciamento de memória, portabilidade, utilização em dispositivos diversos e custo.

- Versões do Java

	LTS ("Long Term Support" ou "suporte de longo prazo") - são versões com maior tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia.

	Non-LTS - são versões com menor tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia, normalemnte a cada ano.

- Edições do Java

    Java SE (Java Standard Edition): para programação desktop

    Java EE (Java Enterprise Edition): para programação web

    Java ME (Java Micro Edition): para programação de dispositivos embarcados

    JavaFX: para programação de multimidia

- Kits Java

	Java Runtime Environment (JRE): programa a ser instalado para execução de programas Java, possui a máquina virtual Java (JVM).

	Java Development Kit (JDK): programa a ser instalado para desenvolvimento e execução de programas Java (JVM), possui a máquina virtual Java, as APIs (bibliotecas) de desenvolvimento e o compilador Java.

	Estes kits são disponibilizados para diversos sistemas operacionais, permitindo assim a criação e execução de aplicativos Java nestes ambientes.

- Dicas Eclipse

	Mudar o layout: menu superior "Window" > "Perspective" > "Open Perspective" > escolher a perspectiva desejada

	Zerar o layout: menu superior "Window" > "Perspective" > "Reset Perspective"

	Mostrar a aba Console: menu superior "Window" > "Show View" > "Console"

	Mudar o tamanho da fonte: tecla "CTRL +" para aumentar e "CTRL -" para diminuir

	Importar classes: "CTRL SHIFT O"
	
	Autoendentação: "CTRL SHIFT F"

	Inciar o programa: "CTRL F11"

	Atalhos:

	método "main" - main e depois "CTRL Espaço"

	"System.out.println();" - sysout e depois "CTRL Espaço"

	Gerar método construtor - "botão direito" > "Source" > "Generate Constructor using Fields"

	Gerar métodos getters e setters - "botão direito" > "Source" > "Generate Getters and Setters"

- Debug Eclise

	Para marcar uma linha de breakpoint: clicar duas vezes do lado esquerdo do número da linha (irá marcar uma bolinha)

	Para desmarcar uma linha de breakpoint: clicar duas vezes do lado esquerdo na bolinha ao lado do número da linha (irá desmarcar a bolinha)

	Para iniciar o debug: pressionar a tecla "F11"

	Para executar uma linha: pressionar a tecla "F6"

	Para interromper o debug: pressionar as teclas "CTRL F2"

- Estrutura de uma aplicação Java

	Uma aplicação Java basicamente é composta por classes.

	O agrupamento lógico de classes relacionadas se chama "package".

	O agrupamento lógico de "package's" relacionadas se chama "module".

	O agrupamento lógico de "module's" relacionadas se chama "application".

- Convenções de nomes em Java

	Lower Camel Case ("lastName" por exemplo):

	pacotes
	atributos
	métodos
	variáveis e parâmetros

	Pascal Case ("UserAccount" por exemplo):

	classes

- Comentários

	Comentários em programas Java são códigos dentro dos programas que não serão executados mas server para dar informações relativas ao código.

	Exemplo:

	// Comentario de uma linha

	/*
	* Comentário 
	* de
	* bloco
	*/

- Variáveis

	Em programação, uma variável é uma porção de memória (RAM) utilizada para armazenar dados durante a execução dos programas.

	Declaração sem atribuir valor:

	<tipo> <nome>;

	Declaração atribuirdo valor:

	<tipo> <nome> = <valor inicial>;

	Regras para nomes de variáveis:

	Não pode começar com dígito
	Não pode ter espaço em branco
	Não usar acentos
	Use nomes que tenham significado / relação com o que a variável representa
	Use o padrão "CamelCase", em específico o "lowerCamelCase" (de letra inicial minúscula)

- Tipos primitivos em Java

	São variáveis básicas da linguagem Java, elas guardam o valor dentro delas mesmo.

	Descrição 								Tipo 		Tamanho 	Valores 										Valor padrão

	tipos numéricos inteiros				byte 		8 bits 		-128 a 127 										0
	tipos numéricos inteiros				short 		16 bits 	-32768 a 32767 									0
	tipos numéricos inteiros				int 		32 bits 	-2147483648 a 2147483647 						0
	tipos numéricos inteiros				long 		64 bits 	-9223372036854770000 a 9223372036854770000 		0L
	tipos numéricos com ponto flutuante		float 		32 bits 	-1,4024E-37 a 3,4028E+38 						0.0f
	tipos numéricos com ponto flutuante		double 		64 bits 	-4,94E-307 a 1,79E+308 							0.0
	um caractere Unicode 					char 		16 bits 	'\u0000' a '\uFFFF' 							'\u0000'
	valor verdade 							boolean 	1 bit 		false, true 									false

- Escrevendo na tela

	Sem quebra de linha:

	System.out.print(<texto ou variável a ser exibido na tela>);

	Com quebra de linha:

	System.out.println(<texto ou variável a ser exibido na tela>);

	Com formatação:

	System.out.printf(<marcadores>, <variáveis>);

	Marcadores:

	Especificador 	Formato

	%s 				String
	%d 				Tipos inteiros
	%f 				Tipos de ponto flutuante
	%b 				Booleanos
	%c 				Caracteres
	%n 				Quebra de linha

	Controle de casas decimais para tipo de ponto flutuante:

	Utilizar "%.<quantidade de casas desejadas>f"

- Concatenação de texto

	Para "print" e "println" utilizar o sinal de "+" para concatenação do texto.

	Para "printf" não existe concatenação de texto pois a estrutura é diferente, a frase ja é formatada antes.

- Separador decimal

	Por padrão "print" e "println" utilizam o sistema americano que determina o "." como separador decimal.

	Por padrão "printf" utiliza a localização do sistema operacional para determinar o separador decimal, no caso do Brasil a ",".

	Caso queria alterar para o sistema americano de separador decimal com "." precisamos importar a classe "Locale" no início do programa:

	import java.util.Locale;

	E em seguida, dentro do método, declarar a configuração:

	Locale.setDefault(Locale.US);

- Operadores aritméticos

	+	adição
	-	subtração
	*	multiplicação
	/	divisão
	%	resto da divisão

	Precedência dos operadores

	* / %
	+ -

	Agrupamento de expressões

	Utilizamos parênteses ( ) para agrupamento de expressões aritméticas.

- Operadores de atribuição acumulativa

	Usados como forma abreviada de escrever que uma variável recebe o valor dela em uma operação onde ela esta envolvida.

	Operador 		Exemplo de uso

	+= 				a = a + b;
	-= 				a = a - b;
	*= 				a = a * b;
	/= 				a = a / b;
	%= 				a = a % b;

- Casting

	Conversão entre tipos de variáveis, temos dois tipos, implicita (automatica) e explicita (forçada).

	É necessário quando o compilador não é capaz de "adivinhar" que o resultado de uma expressão deve ser de outro tipo.

	Uso:

	A conversão implcita (automatica) não precisa de intervenção alguma.

	A conversão explicita (forçada) é feita colocando o tipo desejado em frente ao valor a ser convertido "(<tipo desejado>) <valor a ser convertido>".

	Tabela de conversão implicita e explicita:

	De / Para	byte 	  short 	 	char 	 	int 	 		long 	 		float 	 		double

	byte 		N/A 	  implicito 	char 		implicito		implicito		implicito		implicito
	short 		byte 	  N/A 			char 		implicito		implicito		implicito		implicito
	char 		byte 	  short		 	N/A 		implicito		implicito		implicito		implicito
	int 		byte 	  short		 	char 		N/A 			implicito		implicito		implicito
	long 		byte 	  short		 	char 		int 			N/A 			implicito		implicito
	float 		byte 	  short		 	char 		int 			long 			N/A 			implicito
	double 		byte 	  short		 	char 		int 			long 			float 			N/A

	O tipo de dado boolean é o único tipo primitivo que não suporta casting.

- Entrada de dados

	Importar a classe "Scanner" no inicio do programa:

	import java.util.Scanner;

	Declarar um objeto Scanner padrão:

	Scanner sc = new Scanner(System.in);

	Para entrada de dados utilziamos os métodos especificos para cada tipo:

	sc.next(); 						Entrada de valor texto sem espaço
	sc.nextLine(); 					Entrada de valor texto de diversas palavras (com espaço)
	sc.next().charAt(0); 			Entrada de valor char
	sc.nextLong(); 					Entrada de valor long
	sc.nextInt(); 					Entrada de valor int
	sc.nextByte(); 					Entrada de valor byte
	sc.nextShort(); 				Entrada de valor short
	sc.nextDouble(); 				Entrada de valor double
	sc.nextFloat(); 				Entrada de valor float
	sc.nextBoolean(); 				Entrada de valor boolean

	Ao término do uso do objeto Scanner o mesmo deve ser fechado:

	sc.close();

	Atenção!

	Quando você usa um comando de leitura diferente do "nextLine()" e dá alguma quebra de linha, essa quebra de linha fica "pendente" na entrada padrão.
	
	Se você então fizer um "nextLine()" aquela quebra de linha pendente será absorvida pelo "nextLine()" e o programa apresentara erro ou algum comportamento estranho.

	Solução: Faça um "nextLine()" extra antes de fazer o "nextLine()" de seu interesse.

- Funções matemáticas

	Existem algumas fucções já pré-definidas em Java, elas fazem parte da classe "Math", seguem exemplos:

	Exemplo 								Significado

	Math.sqrt(<valor x>); 					resultado da raiz quadrada de x
	Math.pow(<valor x>, <valor y>); 		resultado de x elevado a y
	Math.abs(<valor x>); 					resultado da valor absoluto de x

	Existem diversas outras funções já prontas, basta verificar a documentação da classe "java.lan.Math".

- Operadores comparativos

	Operador 		Significado
	
	>  				maior
	<  				menor
	>= 				maior ou igual
	<= 				menor ou igual
	== 				igual
	!= 				diferente

- Operadores lógicos

	Operador 		Significado

	&& 				E
	|| 				OU
	! 				NÃO

- Estruturas de seleção

	if (simples)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		}

	if...else (composta)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else {
			<comandos a serem executados caso a condição acima seja falsa>
		}

	if...else if...else (aninhada)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		}
		...
		} else {
			<comandos a serem executados caso todas as condições acima sejam falsas>
		}

	switch (seleção específica)

		switch (<variavel>) {
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			...
			default:
				<ações a executar caso nenhuma alternativa anterior seja válida>;
		}

	operador ternário ? (seleção dupla)

	(<condição>) ? <valor se verdadeiro> : <valor se falso>;

- Estruturas de repetição

	while (usada quando não se sabe quantas vezes vai repetir, teste no inicio, pode nunca ser executada)

		<declaração da variavel de controle>;

		while (<teste da variável de controle>) {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		}

	for (usada quando se sabe a quantidade de vezes a ser executada, sempre é executada)

		for (<declaração da variável de controle>; <teste da variavel de controle>; <incremento ou decremento da variavel de controle>) {
			<código a ser executado quando a repetição for executada>
		}

	do while (usada quando não se sabe quantas vezes vai repetir, teste no final, é executada ao menos uma vez)

		<declaração da variavel de controle>;

		do {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		} while (<teste da variável de controle>);

- Operadores bitwise (bit a bit)

	Operador 			Significado

	& 					Operação "E" bit a bit
	| 					Operação "OU" bit a bit
	^ 					Operação "OU-exclusivo" bit a bit

- Funções para String

	toLowerCase() - passa a String para lowercase
	toUpperCase() - passa a String para uppercase
	trim() - corta os espaços no começo e no final da String
	substring(<posição inicial>) - cria uma nova String a partir de uma posição ate o final da String
	substring(<posição inicial>, <posição final>) - cria uma nova String a partir de uma posição ate uma posição final
	replace(<char>, <char>) - troca um char da String
	replace(<string>, <string>) - troca uma parte da String
	indexOf(<string>) - retorna a primeira posição onde a String foi encontrada
	lastIndexOf(<string>) - retorna a última posição onde a String foi encontrada
	split(<separador>) - cria um vetor com as substrings criadas pelo separador

- Classes

	É um tipo estruturado que pode conter:

	Atributos
	Métodos

	A classe também pode prover muitos outros recursos, tais como:

	Construtores
	Sobrecarga
	Encapsulamento
	Herança
	Polimorfismo

	Exemplos de classes:

	Entidades: Produto, Cliente, Triangulo
	Serviços: ProdutoService, ClienteService, EmailService, StorageService
	Controladores: ProdutoController, ClienteController
	Utilitários: Calculadora, Compactador
	Outros (views, repositórios, gerenciadores, etc.)

	Caracterisiticas:

	Toda classe possui um nome
	Possue visibilidade (exemplo: public, private, protected ou default)
	Podem possuir membros (exemplo: atributos, métodos)

- Classe principal (Program)

	É a classe "entry-point" da aplicação, a primeira a ser iniciada ao executar um programa em Java.

	Para isso ela possui o método "main".

- Estrutura básica de uma classe

	<pacote que a classe faz parte>;

	<importação de pacotes necessários>;

	<declaração da classe> {
		
		<declaração de atributos>...

		<declaração de métodos>...

	}

	Exemplo:

	package entities;

	import java.util.Locale;

	public class Triangle {

		public double a;
		public double b;
		public double c;
		
		public double area() {
			
			double p = (a + b + c) / 2.0;
			double r = Math.sqrt(p * (p - a) * (p - b) * (p - c));
			
			return r;
		}
		
	}

- Pacotes (package)

	Um pacote ou "package" na tecnologia Java nada mais é do que um conjunto de classes localizadas na mesma estrutura hierárquica de diretórios.

	Usualmente, são colocadas em um package classes relacionadas, construídas com um propósito comum para promover a reutilização de código.

	Deve ser declarado a primeira linha da classe.

	Exemplo:

	package <nome do pacote>;

	package entities;

- Declaração import

	A instrução "import" da linguagem Java tem como objetivo disponibilizar em uma classe, de um determinado pacote, o acesso a demais classes que estejam em pacotes diferentes.

	Para isso basta inserir a dealcração "import" após a declaração "package" da classe, exemplo:

	import <caminho fqdn da classe>;

	import java.util.Locale;

- Modificadores de acesso

	Temos quatro modificadores de acesso básicos da linguagem Java: public, private, protected e default.

	Eles servem para tornar componentes da sua aplicação mais ou menos acessíveis por outras partes do seu programa.

	Resumo dos modificadores:

		public: o membro é acessado por todas classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)

		private: o membro só pode ser acessado na própria classe

		protected: o membro só pode ser acessado no mesmo pacote, bem como em subclasses de pacotes diferentes

		(default): o membro só pode ser acessado nas classes do mesmo pacote		

	Detalhes dos modificadores:

	"public"

	Não impõe restrições de acesso ao item, deixando-o visível para todo e qualquer classe. Esse modificador pode ser aplicado sobre todos os itens:

	    Classes
	    Classes internas
	    Interfaces
	    Interfaces internas
	    Annotations
	    Annotations internas
	    Enum
	    Enums internos
	    Métodos
	    Atributos

	"private"

	O modificador que mais restringe a visibilidade do item marcado deixando-o visível somente para a classe que o definiu. Em uma herança a restrição de acesso atinge também as classes filhas, impedindo-as de acessarem o item sob o modificador private. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"protected"

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes filhas da classe que possui o item e para classes que se encontram sob o mesmo pacote da classe que possui o item. Esse modificador pode ser aplicado sobre os itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"default":

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes que se encontram sob o mesmo pacote da classe que possui o item. Em uma herança a restrição de acesso atinge também as classes filhas que não estejam no mesmo pacote, impedindo-as de acessarem o item sob o modificador default.

	Para esse modificador não há uma palavra chave definida para o uso aqui. O modificador aqui é a omissão dos outros modificadores. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes
	    Classes internas
	    Interfaces internas
	    Annotations  internas
	    Enums internos
	    Métodos
	    Atributos

    Visibilidade de um item com o modificador de acesso

	Para testar a visibilidade de um item com o seu modificador de acesso há cinco cenários diferentes:

    A partir da mesma classe
    Qualquer classe no mesmo package
    Qualquer classe filha no mesmo package
    Qualquer classe filha em package diferente
    Qualquer classe em package diferente

    Para isso utilizamos a tabela abaixo:

	Visibilidade 									public 		protected 		default 	private

    A partir da mesma classe 						OK			OK 				OK 			OK
    Qualquer classe no mesmo package 				OK			OK 				OK 			Não
    Qualquer classe filha no mesmo package 			OK			OK 				OK 			Não
    Qualquer classe filha em package diferente 		OK			OK 				Não 		Não
    Qualquer classe em package diferente 			OK			Não 			Não 		Não

- Atributos

	Os atributos são as propriedades de uma classe, também são conhecidos como variáveis ou campos. Essas propriedades definem o estado de um objeto, fazendo com que esses valores possam sofrer alterações.

	Eles são declarados como variaveis comuns porpém dentro da classe.

	Exemplo:

	int idade;

- Referência "this"

	É uma referenci apara o proprio objeto.

	Usos comuns:

	Diferenciar atributos de variáveis locais
	Passar o próprio objeto como argumento na chamada de um método ou construtor

	Por exemplo, caso algum atributo tenha o mesmo nome de um parâmetro de método  (normalmente no método construtor) podemos referenciar o atributo do objeto com a palavra "this" antes do atributo ao utilizar o mesmo.

	Exemplo:

	this.<nome do atributo>

	this.quantidade = quantidade;

- Métodos

	Representam um processamento que possui um significado.

	As principais vantagens: modularização, delegação e reaproveitamento de código.

	Dados de entrada e saída:

	Funções podem receber dados de entrada (parâmetros)
	Funções podem ou não retornar uma saída

	Estrutura:

	<modificador de acesso> <propriedade de instanciação se necessário> <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	Exemplo:

	public static int max(int x, int y, int z) {

		int maxNumber;

		if (x > y && x > z) {
			maxNumber = x;
		} else if (y > x && y > z) {
			maxNumber = y;
		} else {
			maxNumber = z;
		}

		return maxNumber;
	}

- Método "main"

	É o primeiro método executado em um programa Java, considerado como o "entry-point" da aplicação.

	Normalmente ele está na classe "Program".

	Ele deve ser declarado sempre da mesma forma:

	public static void main(String[] args) {
		<código do método>
	}

- Objeto

	Uma classe é como se fosse uma planta de uma casa, um  desenho, um projeto de algo. Não podemos utilizar uma planta de uma casa para morar, precisamos contruir a casa.

	Desta forma um objeto é como se fosse a casa construida a partir da planta.

	A classe tem a descrição do que o objeto possui e faz, mas é somente um projeto, para utilizarmos a classe criamos onjetos baseados nela.

- Declaração e instanciação de um objeto

	Para criarmos um objeto temos dois passos, a declaração e a instanciação.

	A declaração de um objeto é feito igual a uma variavel comum.

	Exemplo:

	<nome da classe> <nome do objeto>;

	Triangulo t;

	Ela cria na memória uma variável com conteúdo vazio.

	Instanciar é o ato de criar o objeto na memória e inserir seu endereço dentro da variavel criada anteriormente.

	Exemplo:

	<nome do objeto> = new <nome da classe>(<paramentros se necessario):

	t = new Triangulo(2.00, 3.00, 5.00);

	Uma variavel do tipo comum (primitiva) guarda dentro dela o valor propriamente dito, ja uma variavel do tipo objeto guarda um valor de enderço de memoria que redireciona a variavel (como um link ou ponteiro) ao local onde os dados efetivamente estao.

- Linguagem UML

	A Linguagem de Modelagem Unificada (UML) foi criada para estabelecer uma linguagem de modelagem visual comum, semanticamente e sintaticamente rica, para arquitetura, design e implementação de sistemas de software complexos, tanto estruturalmente quanto para comportamentos.

	A UML não é uma linguagem de programação, ela mostra as classes (com seus atributos e métodos) e seus relacionamentos com outras classes, tudo em forma de desenho.

	Podemos dizer que a UML mostra o projeto da classe ou diagrama de classes.

- Diagrama UML

	-------------------------
	| <nome da classe>      |
	-------------------------
	| <atributos da classe> |
	-------------------------
	| <métodos da classe>   |
	-------------------------

	Exemplo:

	-----------------------------------------
	|               Triangle                |
	-----------------------------------------
	| - A: double                           |
	| - B: double                           |
	| - C: double                           |
	-----------------------------------------
	| + area(X: double, Y: double): double  |
	-----------------------------------------

	Detalhes:

	O nome da classe é escrito em negrito e com alinhamento centralizado.

	Temos modificadores de acesso igual ao Java:

	"-" para private
	"#" para protected
	"+" para public
	"~" para default

	Os atributos possuem alinhamento a esquerda na seguinte estrutura:

	"<modificador de acesso> <nome da variavel>: <tipo da variavel>"

	Os métodos possuem alinhamento a esquerda na seguinte estrutura:

	"<modificador de acesso> <nome do método>(<nome do parametro>: <tipo do parametro>): <tipo da variavel de retorno>"

- Classe "Object"

	Toda classe em Java é uma subclasse da classe "Object".

	Object possui os seguintes métodos:

	getClass()- retorna o tipo do objeto
	equals() - compara se o objeto é igual a outro
	hashCode() - retorna um código hash do objeto
	toString() - converte o objeto para string

- Método "toString()"

	Ao tentar imprimir um objeto diretamente no console recebemos como resultado o nome do pacote e classe ao qual o objeto pertence, assim como seu endereço de memória.

	Exemplo:

	entities.Product@6108b2d7

	Esta informação não tem muita utilidade.

	Caso seja necessario retornar informações relativas a atributos e métodos do objeto como uma String devemos utilizar o método "toString()".

	Este método existe na classe pai "Object" e é herdada por todos os objetos em Java, desta forma a implementação feita em "Object" retorna o exemplo citado acima.

	Podemos reescrever este método em nossas classes, retornando dentro dele como gostariamos que o objeto fosse impresso em um console.

	Para isso utilizamos a estrutura abaixo:

	@Override
	public String toString() {
		return <dados a serem exibidos do objeto>
	}

	Exemplo:

	@Override
	public String toString() {
		return name + ", " + quantity;
	}

	O "@Override" serve para mostrar que este método esta reescrevendo um método ja definido em uma classe pai.

- Método "String.format()"

	Utilizado para aplicar formatação similar ao "printf" em uma String.

	Exemplo:

	return name + ", " + String.format("%.2f", quantity);

	Normalmente é utilizada junto ao método "toString()".

- Membros de instancia

	Uma classe possui membros, esses membros são os atributos e os métodos.

	Ao criar e instanciar um objeto cada um irá possuir uma cópia (instancia) dos membros, estes membros são chamados de "membro de intancia" ou "menbros de objeto".

	Cada objeto conhece somente os seus membros, membros de outros objetos (mesmo sendo da mesma classe) não são conhecidos.

- Membros estaticos

	Também chamados membros de classe em oposição a membros de instância.

	São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe.

	Exemplo:

	Math.sqrt

	Não precisamos instanciar um objeto da classe Math para utiliza-la, basta chamamos seus métodos de forma direta.

	Aplicações comuns:

	Classes utilitárias
	Declaração de constantes

	Uma classe que possui somente membros estáticos, pode ser uma classe estática também. Esta classe não poderá ser instanciada.

	Para declarar um mebro estatico basta inserir a palavra "static" em sua declaração.

	Exemplo:

	Atributos:

	public static <tipo da variavel> <nome da variável> = <valor da variável>;

	public static double pi = 3.14159;
	
	Métodos:

	<modificador de acesso> static <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	public static double volume(double radius) {
		return (4.0 * PI * Math.pow(radius, 3)) / 3;
	}

- Constantes

	Uma constante é um tipo especial de variável cujo valor, uma vez definido no código, não pode mais ser alterado durante a execução do programa.

	Declaramos uma constante em Java usando a palavra-chave final.
	
	Exemplo:

	public static final double PI = 3.14159;

	Declarar sempre uma constante usando apenas letras maiúsculas, e em caso de palavras compostas, separá-las com um underline (_).

- Construtores

	É uma operação especial da classe, que executa no momento da instanciação do objeto.

	Usos comuns:

	Iniciar valores dos atributos
	Permitir ou obrigar que o objeto receba dados / dependências no momento de sua instanciação (injeção de dependência)

	Se um construtor customizado não for especificado, a classe disponibiliza o construtor vazio (default) que instacia o objeto com valores padrão de cada tipo.

	Valores padrão:

	Descrição 								Valor padrão

	tipos numéricos inteiros				0
	tipos numéricos com ponto flutuante		0.0
	tipo char 			 					'\u0000' (null)
	tipo boolean 							false
	tipo object 							null

	Também é possível especificar mais de um construtor na mesma classe (sobrecarga).

	Declaração:

	Construtor vazio (default)

		Basta não declarar nenhum método construtor na classe e instaciar a mesma passando sem passar nenhum argumento entre os parenteses, por exemplo:

		Product p = new Product();

		Desta forma os atributos do objeto serão inicializados com o valor padrão para cada tipo.

		Atenção, o construtor vazio so funciona se não existir nenhu outro construtor dentro da classe, caso exista algum construtor o mesmo deve ser utilziado e instanciar um objeto sem parametros resultara em erro.

	Contrutor padrão

		Para criarmos um contrutor padrão devemos criar um método dentro da classe que será instanciada, o método possuirá o nome da propria classe, seguindo a estrutura abaixo:

		<public <nome da classe>(<parametros>) {
			this.Nome do atributo interno da classe> = <parametro>...
		}

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = quantity;
		}

		Caso algum atributo necessite ser iniciado com valor especifico podemos colocar dentro do construtor tambem, por exemplo:

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = 0;
		}

- Sobrecarga de métodos

	É um recurso que uma classe possui de oferecer mais de uma método com o mesmo nome, porém com diferentes listas de parâmetros.

	Pode ser utilizado em métodos comuns e em construtores.

	Segue exemplo com construtores:

	// Construtor com valores default
	public Product() {
	}
	
	// Construtor recebendo os 3 parametros
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	// Construtor recebendo 2 parametros e um com valor default
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}

- Encapsulamento

	É um princípio que consiste em esconder detalhes de implementação de uma classe, expondo apenas operações seguras e que mantenham os objetos em um estado consistente.

	O objeto deve sempre estar em um estado consistente, e a própria classe deve garantir isso.

	Regra geral básica:

	Um objeto NÃO deve expor nenhum atributo (atributos devem ter modificador de acesso private)
	Os atributos devem ser acessados por meio de métodos get e set

	Padrão para implementação de métodos getters e setters

	O método get é utilizado para recuperar o valor do atributo, exemplo de declaração:

	public <tipo de retorno> get<nome do atributo>() {
		return <atributo>;
	}

	public String getName() {
		return name;
	}

	O método set é utilizado para configurar o valor do atributo, exemplo de declaração:

	public void set<nome do atributo>(<tipo do parametro> <parametro>) {
		this.<nome do atributo> = <parametro>;
	}

	public void setName(String name) {
		this.name = name;
	}

- Área de memória Heap e Stack

	O sistema operacional ao carregar um programa na memória  disponibiliza ao programa um espaço de endereçamento, esse espaço é a memória disponível para aquele programa.

	O Heap, ou área de alocação dinâmica, é um espaço reservado para variáveis e dados criados durante a execução do programa. Vamos dizer que o Heap é a memória global do programa.

	O Stack é uma área da memória que aloca dados, variáveis ou ponteiros quando uma função é chamada e desalocada quando a função termina. Podemos dizer então que representa a memória local àquela função. 

- Variáveis tipos valor (primitivos) vs tipos referência (classes)

	Variáveis tipos valor (primitivos) são criados na área Stack, são como se fossem caixas que guardam exatamente o valor que for atribuido a variável, por exemplo, se atribuirmos o valor 1 a variável teremos o valor 1 dentro da caixa.

	Variáveis Tipos referência (classes) são criados inicialmente na área Stack, são como se fossem caixas assim como os tipos primitivos, mas diferente deles as caixas não guardam os valores atribuidos a variável e sim um valor de memória que aponta para um local na área Heap. Neste local da area Heap teremos uma caixa que irá guardar os valores do objeto. Funcionando como um ponteiro.

	Tabela comparativa:

	Classe																					Tipo Primitivo

	Vantagem: usufrui de todos recursos OO 													Vantagem: é mais simples e mais performático
	Variáveis são ponteiros 																Variáveis são caixas
	Objetos precisam ser instanciados ou apontar para um objeto já existente. 				Não instancia. Uma vez declarados, estão prontos para uso.
	Aceita valor null 																		Não aceita valor null
	Y = X; "Y passa a apontar para onde X aponta" 											Y = X; "Y recebe uma cópia de X"
	Objetos instanciados no heap 															Variaveis são criadas no stack
	Objetos não utilizados são desalocados em um momento próximo pelo garbage collector 	Variaveis são desalocados imediatamente quando seu escopo de execução é finalizado

- Garbage collector

	É um processo que automatiza o gerenciamento de memória de um programa em execução.

	O garbage collector monitora os objetos alocados dinamicamente pelo programa (no heap), desalocando aqueles que não estão mais sendo utilizados (não possuem mais ponteiros apontando para eles).

- Desalocação por garbage collector e por escopo

	A desalocação por garbage collector é feita automaticamente, sem intervenção do usuário, de tempos em tempos. Funciona para tipos referencias (classes).

	A desalocação por escopo é feita assim que o escopo onde a variável foi criada é encerrado, pode ser um método, uma estrutura de repetição ou de seleção. Funciona para tipos valor (primitivos).

- Vetor (array)

	Vetor (array) é o nome dado a arranjos unidimensionais.

	Vetor é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo do vetor>[] <nome da variavel>;

		double[] number;

	Instanciação:

		<nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		number = new double[3];

	Declaração e instanciação na mesma linha:

		<tipo do vetor>[] <nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		double[] number = new double[3];

	Atributos de um vetor:

		length - mostra o tamanho do vetor

- Boxing, unboxing e wrapper classes

	Boxing

		É o processo de conversão de um objeto tipo valor (primitivo) para um objeto tipo referência compatível, exemplo:

		int x = 20;
		Object obj = x;

	Unboxing:

		É o processo de conversão de um objeto tipo referência para um objeto tipo valor compatível, exemplo:

		int x = 20;
		Object obj = x;
		int y = (int) obj;

		O processo de Boxing é feito de forma implicita, já o processo de Unboxing é feito de forma explicita (com casting).

	Wrapper classes

		Para facilitar o processo de Boxing e Unboxing foram criadas as wrapper classes, elas são classes equivalentes aos tipos primitivos, segue tabela:

		Tipo primitivo 			Wrapper classes

		byte					Byte
		short					Short
		int						Integer
		long					Long
		float					Float
		double					Double
		char					Character
		boolean					Boolean

		Uso comum: campos de entidades em sistemas de informação, pois tipos referência (classes) aceitam valor null e usufruem dos recursos OO.

		Atributos de classes devem ser declarados como Wrapper classes para boa prática, exemplo:

		public class Product {
			private String name;
			private Double price;
			private Integer quantity;
			(...)

		A wrappers classes podem ser utilizadas como se fosse um tipo primitivo normalmente, inclusive em calculos, exemplo:

		Integer x = 10;
		int y = x * 2;

- Laço "for each"

	Sintaxe opcional e simplificada para percorrer coleções.

	Ela serve somente para exibição, não serve para modificar os valores dos itens das coleções.

	Sintaxe:

	for (<tipo da coleção> <variavel interna do laço> : <variavel da coleção>) {
		<comandos aserem executados>
	}

	Exemplo:

	String[] vect = new String[] {"Bolacha", "Minhoca", "Gabriel"};
	
	for (String nome : vect) {
		System.out.println(nome);
	}

- Listas

	Lista é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Inicia vazia, e seus elementos são alocados sob demanda
		Cada elemento ocupa um "nó" (ou nodo) da lista
		Não aceita tipos primitivos, somente classes

	Seu tipo é o "List".

	Podemos declarar um tipo como "List" porem não podemos instanciar devido a ser uma interface, a instanciação deve ser feita em uma de suas implementações.

	Seguem algumas classes que implementam "List":

		AbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector

	Vantagens:

		Tamanho variável
		Facilidade para se realizar inserções e deleções

	Desvantagens:

		Acesso sequencial aos elementos

	Declaração:

		List<tipo a ser guardado> <nome da lista> = new <implementação da lista><>();

		List<String> list = new ArrayList<>();

	Métodos:

		size() - mostra o tamanho da lista
		add(<elemento>) - adicionar elemento na ultima posição
		add(<posição>, <elemento>) - adicionar elemento na posição desejada
		remove(<elemento ou posição>) - remover elemento da lista
		get(<posição>) - obter o elemento da posição
		indexOf(<elemento>) - busca o primeiro elemento na lista com o valor desejado
		indexOf(<elemento>) - busca o ultimo elemento na lista com o valor desejado

- Matrizes

	Matriz é o nome dado a arranjos bidimensionais.

	Matriz é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo da matriz>[][] <nome da variavel>;

		double[][] number;

	Instanciação:

		<nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		number = new double[2][3];

	Declaração e instanciação na mesma linha:

		<tipo da matriz>[][] <nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		double[][] number = new double[2][3];

	Atributos de um vetor:

		length - mostra o tamanho de linhas ou colunas da matriz

- Datas

	Classe "Date"

		Para datas em Java utilizamos a classe "Date", ela faz parte do pacote "java.util".

		Desta forma para utilza-la devemos importar a classe da seguinte forma:

		import java.util.Date;

		Um objeto Date internamente armazena o número de milissegundos (tipo long) desde a meia noite do dia 1 de janeiro de 1970 (UTC - timezone GMT).

		A prática comum é salvar sempre as datas no formato UTC e efetuar a conversão para leitura / gravação conforme o timezone local.

		Exemplo de declaração:

		Date <nome da variável>;

		Podemos instanciar uma data de vária formas, por exemplo:

		new Date() - momento atual
		new Date(System.currentTimeMillis()) - momento atual
		new Date(<tempo em milisegundos>L) - momento que usa como referência os milisegundos a partir de "1 de janeiro de 1970 00:00:00"

		Mas o mais comum é instanciar um objeto Date partindo de uma data em String, para isso utilizamos uma classe de formatação de datas, a classe "SimpleDateFormat".

	Classe "SimpleDateFormat"

		Para formatação de datas utilizamos a classe "SimpleDateFormat", ela faz parte do pacote "java.text".

		Desta forma para utilza-la devemos importar a classe da seguinte forma:

		import java.text.SimpleDateFormat;

		Essa classe define formatos (máscaras) para conversão entre Date e String, seu uso principal é para instanciar um objeto Date a partir de uma data em String ou para exibir um objeto Date em um formato específico.

		Exemplo de declaração:

		SimpleDateFormat sdf;

		Exemplo de instanciação:

		sdf = new SimpleDateFormat("<mascara>");

		Podemos instanciar com diversas máscaras, por exemplo:

		"dd/MM/yyyy"                   - 23/07/2018
		"dd/MM/yyyy HH:mm:ss"          - 23/07/2018 15:42:07
		"yyyy.MM.dd G 'at' HH:mm:ss z" - 2001.07.04 AD at 12:08:56 PDT
		"EEE, MMM d, ''yy"             - Wed, Jul 4, '01
		"h:mm a"                       - 12:08 PM
		"hh 'o''clock' a, zzzz"        - 12 o'clock PM, Pacific Daylight Time
		"K:mm a, z"                    - 0:08 PM, PDT
		"yyyyy.MMMMM.dd GGG hh:mm aaa" - 02001.July.04 AD 12:08 PM
		"EEE, d MMM yyyy HH:mm:ss Z"   - Wed, 4 Jul 2001 12:08:56 -0700
		"yyMMddHHmmssZ"                - 010704120856-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSZ"   - 2001-07-04T12:08:56.235-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSXXX" - 2001-07-04T12:08:56.235-07:00
		"YYYY-'W'ww-u"                 - 2001-W27-3

		As máscaras são criadas a partir da tabela abaixo:

		Letter 		Date or Time Component 									Presentation 				Examples

		G 			Era designator 											Text 						AD
		y 			Year 													Year 						1996; 96
		Y 			Week year 												Year 						2009; 09
		M 			Month in year 											Month 						July; Jul; 07
		w 			Week in year 											Number 						27
		W 			Week in month 											Number 						2
		D 			Day in year 											Number 						189
		d 			Day in month 											Number 						10
		F 			Day of week in month 									Number 						2
		E 			Day name in week 										Text 						Tuesday; Tue
		u 			Day number of week (1 = Monday, ..., 7 = Sunday) 		Number 						1
		a 			Am/pm marker 											Text 						PM
		H 			Hour in day (0-23) 										Number 						0
		k 			Hour in day (1-24) 										Number 						24
		K 			Hour in am/pm (0-11) 									Number 						0
		h 			Hour in am/pm (1-12) 									Number 						12
		m 			Minute in hour 											Number 						30
		s 			Second in minute 										Number 						55
		S 			Millisecond 											Number 						978
		z 			Time zone 												General time zone 			Pacific Standard Time; PST; GMT-08:00
		Z 			Time zone 												RFC 822 time zone 			-0800
		X 			Time zone 												ISO 8601 time zone 			-08; -0800; -08:00

		Criando um objeto Date:

		Utilizamos o método "parse" para transformar o texto em um objeto Date, por exemplo:

		Date date = sdf.parse("23/07/2018");

		Imprimindo um objeto Date:

		Utilizamos o método "format" para imprimir um objeto Date, por exemplo:

		System.out.println(sdf.format(data));

		Por padrão é utilizado o timezone local da máquina, para alterarmos devemos definir a configuração em um objeto "SimpleDateFormat" conforme abaixo:

		sdf.setTimeZone(TimeZone.getTimeZone("<timezone desejado>"));

		Por exemplo, timezone "GMT":

		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));

		Esta alteração necessita do import da classe "java.util.TimeZone";

	Classe "Instant"

		A partir do Java versão 8 foram criadas novas classes para tratamento de datas, uma delas é a classe Instant.

		Éla é utilizada para transformar uma data texto no formato ISO 8601 (UTC) em objeto "Date".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.time.Instant;

		O padrao utilizado para gravação de datas é o ISO 8601 que compreende o seguinte formato:

		yyyy-MM-ddTHH:mm:ssZ

		Exemplo:

		2018-06-25T15:42:07Z

		Utilizamos o seguinte modo de conversão:

		Date <nome da variável> = Date.from(Instant.parse("<data no formato texto ISO 8601"));

		Exemplo:

		Date date = Date.from(Instant.parse("2018-06-25T15:42:07Z"));

	Classe "Calendar"

		Para pegarmos informação especifica de uma data ou efetuarmos calculos com datas utilizamos a classe "Calendar", ela faz parte do pacote "java.util".

		Desta forma para utilza-la devemos importar a classe da seguinte forma:

		import java.util.calendar;

		Exemplo de declaração / instanciação:

		Calendar cal = Calendar.getInstance();

		Temos diversos usos para esa classe.

		Atribuindo uma data ao calendario:

		cal.setTime(<objeto Date>);

		Atribuindo uma data de calendário para um objeto Date:

		<objeto Date> = cal.getTime();

		Adicionando ou subtraindo tempo a data do calendario:

		cal.add(<o que será atribuido (verificar na documentação)>, <quantidade a ser atribuida ou subtraida com valor negativo>);

- Git e Github

	GIT - é um sistema de versionamento: você controla as modificações de um projeto por meio de versões chamadas "commits".

		Um projeto controlado pelo Git é chamado de repositório de versionamento. Tipicamente uma cópia "oficial" do repositório fica salvo em um servidor (repositório remoto). Cada pessoa que trabalha no projeto pode fazer uma cópia do repositório para seu computador (repositório local). A pessoa então faz suas alterações no projeto (novos commits) e depois salva as alterações no servidor.

		Operações principais:

		CLONE  - Copia o repositório remoto para seu computador
		PULL   - Atualiza seu repositório local em relação ao repositório remoto
		COMMIT - Salva uma nova versão (tipicamente no seu repositório local)
		PUSH   - Envia o repositório local para o repositório remoto

		O Git pode ser usado por ou por terminal de comando, ou por um aplicativo gráfico.

	GITHUB - é um serviço de hospedagem de repositórios Git remotos.

		Caracteristicas:

		Possui uma interface gráfica web: github.com
		É uma plataforma social (usuários, página de perfil, seguidores, colaboração, etc.). Dica: currículo!
		Maior serviço do mundo de hospedagem de projetos de código aberto
		Modelo de cobrança: gratuito para projetos de código aberto, pago para projetos privados
		Alternativas: BitBucket, GitLab, etc.

	Instalação do GIT

		Opções recomendadas:

		Use Vim as Git's default editor
		Use Git from the Windows Command Prompt
		Use the OpenSSL library
		Checkout Windows-style, commit Unity-style line endings
		Use MinTTY
		DESMARCAR: Enable Git Credential Manager

	Criar um novo projeto

		Passos:

		1. Crie um novo projeto no seu ambiente de desenvolvimento

		2. Crie um novo repositório no Github
		ATENÇÃO: se seu ambiente de desenvolvimento não gera o arquivo .gitignore automaticamente, escolha o seu tipo desejado de .gitignore na tela de criação de repositório do Github

		3. Abra um terminal na pasta do seu projeto

		4. IMPORTANTE: certifique-se de estar identificado no Git do seu computador (nome e email) executando os comandos abaixo
		git config --list
		git config --global user.name "Nelio Alves"
		git config --global user.email "acenelio@gmail.com"

		5. Faça os comandos a seguir

		- Inicia um novo repositório local na pasta do seu projeto
		git init

		-Associa seu repositório local ao repositório remoto, com o apelido de "origin"
		ATENÇÃO: troque pelo caminho do seu repositório do Github
		git remote add origin https://github.com/acenelio/<URL do meu projeto>.git

		- Atualiza seu repositório local em relação ao repositório remoto
		ATENÇÃO: este comando só é necessário se você criou o .gitignore pelo Github
		git pull origin master

		- Verifica arquivos
		git status

		- Adiciona todos arquivos ao stage
		git add .

		- Salva uma nova versão do projeto
		git commit -m "<mensagem de commit>"

		- Envia o repositório local para o repositório remoto
		ATENÇÃO: nas próximas vezes basta fazer: git push
		git push -u origin master

	Arquivo .gitignore

		Para quê serve o arquivo .gitignore?

		Serve para informar o GIT quais arquivos devem ser ignorados no sincronismo, isso faz com que arquivos d elog ou compilados por exemplo nao sejam enviados ao Github. Isso econimiza tempo no sincronismo e espaço no projeto.

		Como saber o que colocar no arquivo .gitignore?

		Normalmente ao criar um projeto no Github temos um campo para selecionar um template para o .gitignore, podemos utilizar o mesmo sem problema e ir adequando posteriormente caso necessário.

	Trabalhando com um projeto existente

		Passos:

		1 - Clonar o repositório do Github

		git clone <URL do projeto>

		2 - Importar o projeto no programa editor

		3 -  Altere o que você precisar no projeto

		4 - Commitar as mudanças feitas no projeto

		git status
		git add .
		git commit -m "<mensagem de commit>"
		git log --oneline

		5 - Salvar projeto atualizado no seu Github

		git push

	A sequência de commits deve ser respeitada

		Sempre execute o omando "git pull" para sincronizar seu repositorio local antes de editar o codigo e antes de executar um commit.

		Caso seu repositorio local esteja diferente do remoto e voce tente efetuar um comando git push será apresentado erro.

	Kit de primeiros socorros

		Problema 																					Comando

		Quero desfazer tudo que eu fiz desde o último commit 										git clean -df
																									git checkout -- .

		Preciso remover o último commit, porém mantendo os arquivos do jeito que estão 				git reset --soft HEAD~1

		Preciso remover o último commit, inclusive as alterações nos arquivos						git reset --hard HEAD~1

		Quero alterar temporariamente os arquivos do projeto 										git checkout <código do commit>
		de modo a ficarem no estado do commit informado
		ATENÇÃO: não podem haver modificações não commitadas no projeto
		NOTA: para voltar ao último commit faça: 													git checkout master

		Preciso apagar o último commit no Github 													git push -f origin HEAD^:master

		Quero mudar o meu repositório remoto "origin" 												git remote set-url origin <URL do projeto>

		Entrei no VIM por engano. Como sair? 														Tecle ESC, depois digite :q! e tecle ENTER

- Enumerações

	É um tipo especial que serve para especificar de forma literal um conjunto de constantes relacionadas.

	Palavra chave em Java: enum

	Vantagem: melhor semântica, código mais legível e auxiliado pelo compilador

	Em um caso comum ela é utilizada para substituir uma variavel array de uma classe que contenha caracteristicas de um objeto.

	Ela é declarada da seguinte forma:

		package entities.enums;

		public enum <nome da enum> {
			<itens da enum>
			...
		}

	Exemplo:

		package entities.enums;

		public enum OrderStatus {
			PENDING_PAYMENT,
			PROCESSING,
			SHIPPED,
			DELIVERED;
		}

	Para utilizar basta importar a enum e declarar como uma variavel da seguinte forma:

		import entities.enums.<nome da enum>;
		....
		<modificador de acesso> <nome da enum> <nome da variavel>;

	Exemplo:

		import entities.enums.OrderStatus;
		...
		private OrderStatus status;

	O acesso a uma constante da enu é feito da seguinte forma:

		<nome da variavel>.<constante>;

	Exemplo:

		status.PENDING_PAYMENT;

	
