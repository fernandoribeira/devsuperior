
- Algoritmo

	Sequência finita de instruções para se resolver um problema, aplicando-se a diversas áreas de conhecimento.

- Automação

	Consiste em utilizar uma máquina para executar o procedimento desejado de forma automática ou semiautomática.

- Computador

	Um computador é composto por:

	Hardware - parte física (as peças)
	Software - parte lógica (os programas)

- Programa de computador

	Programas de computador são algoritmos executados pelo computador.

	O computador é uma máquina que automatiza a execução de algoritmos.

	Porém funciona apenas para algoritmos computacionais como processamento de dados e cálculos.

- O que é preciso para se fazer um programa de computador

	Vamos precisar de:

	Uma linguagem de programação
	Uma IDE (Integrated Development Environment ou Ambiente de Desenvolvimento Integrado)
	Um compilador
	Um gerador de código ou máquina virtual

- Linguagem de programação


	É um conjunto de regras léxicas (ortografia) e sintáticas (gramática) para se escrever programas.

	Léxica diz respeito à correção das palavras "isoladas" (ortografia).

	Sintática diz respeito à correção das sentenças (gramática).

	Exemplos de linguagens de programação: C, Pascal, C++, Java, C#, Python, Ruby, PHP, JavaScript, etc.

- IDE

	IDE significa "Integrated Development Environment" ou traduzindo "Ambiente de Desenvolvimento Integrado".

	É um conjunto de softwares utilizado para a construção de programas, exemplos:

	C/C++ - Code Blocks
	Java -  Eclipse, NetBeans
	C# - Microsoft Visual Studio

	Funcionalidades de uma IDE:

	Edição de código fonte (endentação, autocompletar, destaque de palavras, etc.)
	Depuração e testes
	Construção do produto final
	Sugestão de modelos
	Auxiliar em várias tarefas do seu projeto

- Código fonte

	É aquele escrito pelo programador em linguagem de programação na construção dos programas.

- Modos de construção de programas

	Compilação
	Interpretação
	Abordagem híbrida

- Compilação

	cria o código fonte > passa pelo compilador (análise léxica e análise sintática) > que cria o código objeto > passa pelo gerador de código > que cria o código executavel específico > que é executado pelo S.O.

	Exemplos de linguagem: C, C++

- Interpretação

	cria o código fonte > passa pelo interpretador (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: PHP, JavaScript

- Abordagem híbrida

	cria o código fonte > passa pelo pré-compilador (análise léxica e análise sintática) > que cria o código Bytecode > passa pela máquina virtual (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: Java, C#

- Vantagens e desvantagens dos modos de construção de programas

	Compilação

	Vantagens: alta velocidade de execução do programa, auxilio do compilador na checagem do programa
	Desvantagens: necessidade de compilar para cada S.O., precisa ser recompilado caso seja alterado

	Interpretação

	Vantagens: não precisa compilar para cada S.O.
	Desvantagens: baixa velocidade de execução do programa, não temos auxilio do compilador na checagem do programa

	Abordagem híbrida

	Vantagens: não precisa compilar para cada S.O., auxilio do compilador na checagem do programa
	Desvantagens: média velocidade de execução do programa, precisa ser recompilado caso seja alterado

- Três operações básicas de programação

	Entrada de dados: normalmemnte feita pelo teclado ou mouse

	Processamento de dados: feita pelo processador

	Saída de dados: normalmente feito pelo monitor

- Java

	É uma linguagem de programação, plataforma de desenvolvimento e execução de programas.

	Criada pela Sun Microsystems no meio da década de 1990 e adquirida pela Oracle Corporation em 2010.

	Desenhada para ser utilizada em todos os tipos de dispositivos, principalmente portáteis.

	É uma linguagem orientada a objetos, segura, robusta e que domina o mercado a muitos anos.

	Resolve problemas de linguagens antigas como ponteiros / gerenciamento de memória, portabilidade, utilização em dispositivos diversos e custo.

- Versões do Java

	LTS ("Long Term Support" ou "suporte de longo prazo") - são versões com maior tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia.

	Non-LTS - são versões com menor tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia, normalemnte a cada ano.

- Edições do Java

    Java SE (Java Standard Edition): para programação desktop

    Java EE (Java Enterprise Edition): para programação web

    Java ME (Java Micro Edition): para programação de dispositivos embarcados

    JavaFX: para programação de multimidia

- Kits Java

	Java Runtime Environment (JRE): programa a ser instalado para execução de programas Java, possui a máquina virtual Java (JVM).

	Java Development Kit (JDK): programa a ser instalado para desenvolvimento e execução de programas Java (JVM), possui a máquina virtual Java, as APIs (bibliotecas) de desenvolvimento e o compilador Java.

	Estes kits são disponibilizados para diversos sistemas operacionais, permitindo assim a criação e execução de aplicativos Java nestes ambientes.

- Dicas Eclipse

	Mudar o layout: menu superior "Window" > "Perspective" > "Open Perspective" > escolher a perspectiva desejada

	Zerar o layout: menu superior "Window" > "Perspective" > "Reset Perspective"

	Mostrar a aba Console: menu superior "Window" > "Show View" > "Console"

	Mudar o tamanho da fonte: tecla "CTRL +" para aumentar e "CTRL -" para diminuir

	Importar classes: "CTRL SHIFT O"
	
	Autoendentação: "CTRL SHIFT F"

	Inciar o programa: "CTRL F11"

	Atalhos:

	método "main" - main e depois "CTRL Espaço"

	"System.out.println();" - sysout e depois "CTRL Espaço"

	Gerar método construtor - "botão direito" > "Source" > "Generate Constructor using Fields"

	Gerar métodos getters e setters - "botão direito" > "Source" > "Generate Getters and Setters"

- Debug Eclise

	Para marcar uma linha de breakpoint: clicar duas vezes do lado esquerdo do número da linha (irá marcar uma bolinha)

	Para desmarcar uma linha de breakpoint: clicar duas vezes do lado esquerdo na bolinha ao lado do número da linha (irá desmarcar a bolinha)

	Para iniciar o debug: pressionar a tecla "F11"

	Para executar uma linha: pressionar a tecla "F6"

	Para interromper o debug: pressionar as teclas "CTRL F2"

- Estrutura de uma aplicação Java

	Uma aplicação Java basicamente é composta por classes.

	O agrupamento lógico de classes relacionadas se chama "package".

	O agrupamento lógico de "package's" relacionadas se chama "module".

	O agrupamento lógico de "module's" relacionadas se chama "application".

- Convenções de nomes em Java

	Lower Camel Case ("lastName" por exemplo):

	pacotes
	atributos
	métodos
	variáveis e parâmetros

	Pascal Case ("UserAccount" por exemplo):

	classes

- Comentários

	Comentários em programas Java são códigos dentro dos programas que não serão executados mas server para dar informações relativas ao código.

	Exemplo:

	// Comentario de uma linha

	/*
	* Comentário 
	* de
	* bloco
	*/

- Variáveis

	Em programação, uma variável é uma porção de memória (RAM) utilizada para armazenar dados durante a execução dos programas.

	Declaração sem atribuir valor:

	<tipo> <nome>;

	Declaração atribuirdo valor:

	<tipo> <nome> = <valor inicial>;

	Regras para nomes de variáveis:

	Não pode começar com dígito
	Não pode ter espaço em branco
	Não usar acentos
	Use nomes que tenham significado / relação com o que a variável representa
	Use o padrão "CamelCase", em específico o "lowerCamelCase" (de letra inicial minúscula)

- Tipos primitivos em Java

	São variáveis básicas da linguagem Java, elas guardam o valor dentro delas mesmo.

	Descrição 								Tipo 		Tamanho 	Valores 										Valor padrão

	tipos numéricos inteiros				byte 		8 bits 		-128 a 127 										0
	tipos numéricos inteiros				short 		16 bits 	-32768 a 32767 									0
	tipos numéricos inteiros				int 		32 bits 	-2147483648 a 2147483647 						0
	tipos numéricos inteiros				long 		64 bits 	-9223372036854770000 a 9223372036854770000 		0L
	tipos numéricos com ponto flutuante		float 		32 bits 	-1,4024E-37 a 3,4028E+38 						0.0f
	tipos numéricos com ponto flutuante		double 		64 bits 	-4,94E-307 a 1,79E+308 							0.0
	um caractere Unicode 					char 		16 bits 	'\u0000' a '\uFFFF' 							'\u0000'
	valor verdade 							boolean 	1 bit 		false, true 									false

- Escrevendo na tela

	Sem quebra de linha:

	System.out.print(<texto ou variável a ser exibido na tela>);

	Com quebra de linha:

	System.out.println(<texto ou variável a ser exibido na tela>);

	Com formatação:

	System.out.printf(<marcadores>, <variáveis>);

	Marcadores:

	Especificador 	Formato

	%s 				String
	%d 				Tipos inteiros
	%f 				Tipos de ponto flutuante
	%b 				Booleanos
	%c 				Caracteres
	%n 				Quebra de linha

	Controle de casas decimais para tipo de ponto flutuante:

	Utilizar "%.<quantidade de casas desejadas>f"

- Concatenação de texto

	Para "print" e "println" utilizar o sinal de "+" para concatenação do texto.

	Para "printf" não existe concatenação de texto pois a estrutura é diferente, a frase ja é formatada antes.

- Separador decimal

	Por padrão "print" e "println" utilizam o sistema americano que determina o "." como separador decimal.

	Por padrão "printf" utiliza a localização do sistema operacional para determinar o separador decimal, no caso do Brasil a ",".

	Caso queria alterar para o sistema americano de separador decimal com "." precisamos importar a classe "Locale" no início do programa:

	import java.util.Locale;

	E em seguida, dentro do método, declarar a configuração:

	Locale.setDefault(Locale.US);

- Operadores aritméticos

	+	adição
	-	subtração
	*	multiplicação
	/	divisão
	%	resto da divisão

	Precedência dos operadores

	* / %
	+ -

	Agrupamento de expressões

	Utilizamos parênteses ( ) para agrupamento de expressões aritméticas.

- Operadores de atribuição acumulativa

	Usados como forma abreviada de escrever que uma variável recebe o valor dela em uma operação onde ela esta envolvida.

	Operador 		Exemplo de uso

	+= 				a = a + b;
	-= 				a = a - b;
	*= 				a = a * b;
	/= 				a = a / b;
	%= 				a = a % b;

- Casting

	Conversão entre tipos de variáveis, temos dois tipos, implicita (automatica) e explicita (forçada).

	É necessário quando o compilador não é capaz de "adivinhar" que o resultado de uma expressão deve ser de outro tipo.

	Uso:

	A conversão implcita (automatica) não precisa de intervenção alguma.

	A conversão explicita (forçada) é feita colocando o tipo desejado em frente ao valor a ser convertido "(<tipo desejado>) <valor a ser convertido>".

	Tabela de conversão implicita e explicita:

	De / Para	byte 	  short 	 	char 	 	int 	 		long 	 		float 	 		double

	byte 		N/A 	  implicito 	char 		implicito		implicito		implicito		implicito
	short 		byte 	  N/A 			char 		implicito		implicito		implicito		implicito
	char 		byte 	  short		 	N/A 		implicito		implicito		implicito		implicito
	int 		byte 	  short		 	char 		N/A 			implicito		implicito		implicito
	long 		byte 	  short		 	char 		int 			N/A 			implicito		implicito
	float 		byte 	  short		 	char 		int 			long 			N/A 			implicito
	double 		byte 	  short		 	char 		int 			long 			float 			N/A

	O tipo de dado boolean é o único tipo primitivo que não suporta casting.

- Entrada de dados

	Importar a classe "Scanner" no inicio do programa:

	import java.util.Scanner;

	Declarar um objeto Scanner padrão:

	Scanner sc = new Scanner(System.in);

	Para entrada de dados utilziamos os métodos especificos para cada tipo:

	sc.next(); 						Entrada de valor texto sem espaço
	sc.nextLine(); 					Entrada de valor texto de diversas palavras (com espaço)
	sc.next().charAt(0); 			Entrada de valor char
	sc.nextLong(); 					Entrada de valor long
	sc.nextInt(); 					Entrada de valor int
	sc.nextByte(); 					Entrada de valor byte
	sc.nextShort(); 				Entrada de valor short
	sc.nextDouble(); 				Entrada de valor double
	sc.nextFloat(); 				Entrada de valor float
	sc.nextBoolean(); 				Entrada de valor boolean

	Ao término do uso do objeto Scanner o mesmo deve ser fechado:

	sc.close();

	Atenção!

	Quando você usa um comando de leitura diferente do "nextLine()" e dá alguma quebra de linha, essa quebra de linha fica "pendente" na entrada padrão.
	
	Se você então fizer um "nextLine()" aquela quebra de linha pendente será absorvida pelo "nextLine()" e o programa apresentara erro ou algum comportamento estranho.

	Solução: Faça um "nextLine()" extra antes de fazer o "nextLine()" de seu interesse.

- Funções matemáticas

	Existem algumas fucções já pré-definidas em Java, elas fazem parte da classe "Math", seguem exemplos:

	Exemplo 								Significado

	Math.sqrt(<valor x>); 					resultado da raiz quadrada de x
	Math.pow(<valor x>, <valor y>); 		resultado de x elevado a y
	Math.abs(<valor x>); 					resultado da valor absoluto de x

	A classe Math tanbém ja fornece o valor de PI como uma variável:

	Math.PI

	Existem diversas outras funções já prontas, basta verificar a documentação da classe "java.lan.Math".

- Operadores comparativos

	Operador 		Significado
	
	>  				maior
	<  				menor
	>= 				maior ou igual
	<= 				menor ou igual
	== 				igual
	!= 				diferente

- Operadores lógicos

	Operador 		Significado

	&& 				E
	|| 				OU
	! 				NÃO

- Estruturas de seleção

	if (simples)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		}

	if...else (composta)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else {
			<comandos a serem executados caso a condição acima seja falsa>
		}

	if...else if...else (aninhada)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		}
		...
		} else {
			<comandos a serem executados caso todas as condições acima sejam falsas>
		}

	switch (seleção específica)

		switch (<variavel>) {
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			...
			default:
				<ações a executar caso nenhuma alternativa anterior seja válida>;
		}

	operador ternário ? (seleção dupla)

	(<condição>) ? <valor se verdadeiro> : <valor se falso>;

- Estruturas de repetição

	while (usada quando não se sabe quantas vezes vai repetir, teste no inicio, pode nunca ser executada)

		<declaração da variavel de controle>;

		while (<teste da variável de controle>) {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		}

	for (usada quando se sabe a quantidade de vezes a ser executada, sempre é executada)

		for (<declaração da variável de controle>; <teste da variavel de controle>; <incremento ou decremento da variavel de controle>) {
			<código a ser executado quando a repetição for executada>
		}

	do while (usada quando não se sabe quantas vezes vai repetir, teste no final, é executada ao menos uma vez)

		<declaração da variavel de controle>;

		do {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		} while (<teste da variável de controle>);

- Operadores bitwise (bit a bit)

	Operador 			Significado

	& 					Operação "E" bit a bit
	| 					Operação "OU" bit a bit
	^ 					Operação "OU-exclusivo" bit a bit

- Funções para String

	toLowerCase() - passa a String para lowercase
	toUpperCase() - passa a String para uppercase
	trim() - corta os espaços no começo e no final da String
	substring(<posição inicial>) - cria uma nova String a partir de uma posição ate o final da String
	substring(<posição inicial>, <posição final>) - cria uma nova String a partir de uma posição ate uma posição final
	replace(<char>, <char>) - troca um char da String
	replace(<string>, <string>) - troca uma parte da String
	indexOf(<string>) - retorna a primeira posição onde a String foi encontrada
	lastIndexOf(<string>) - retorna a última posição onde a String foi encontrada
	split(<separador>) - cria um vetor com as substrings criadas pelo separador

- Classes

	É um tipo estruturado que pode conter:

	Atributos
	Métodos

	A classe também pode prover muitos outros recursos, tais como:

	Construtores
	Sobrecarga
	Encapsulamento
	Herança
	Polimorfismo

	Exemplos de classes:

	Entidades: Produto, Cliente, Triangulo
	Serviços: ProdutoService, ClienteService, EmailService, StorageService
	Controladores: ProdutoController, ClienteController
	Utilitários: Calculadora, Compactador
	Outros (views, repositórios, gerenciadores, etc.)

	Caracterisiticas:

	Toda classe possui um nome
	Possue visibilidade (exemplo: public, private, protected ou default)
	Podem possuir membros (exemplo: atributos, métodos)

- Classe principal (Program)

	É a classe "entry-point" da aplicação, a primeira a ser iniciada ao executar um programa em Java.

	Para isso ela possui o método "main".

- Estrutura básica de uma classe

	<pacote que a classe faz parte>;

	<importação de pacotes necessários>;

	<declaração da classe> {
		
		<declaração de atributos>...

		<declaração de métodos>...

	}

	Exemplo:

	package entities;

	import java.util.Locale;

	public class Triangle {

		public double a;
		public double b;
		public double c;
		
		public double area() {
			
			double p = (a + b + c) / 2.0;
			double r = Math.sqrt(p * (p - a) * (p - b) * (p - c));
			
			return r;
		}
		
	}

- Pacotes (package)

	Um pacote ou "package" na tecnologia Java nada mais é do que um conjunto de classes localizadas na mesma estrutura hierárquica de diretórios.

	Usualmente, são colocadas em um package classes relacionadas, construídas com um propósito comum para promover a reutilização de código.

	Deve ser declarado a primeira linha da classe.

	Exemplo:

		package <nome do pacote>;

		package entities;

	Sugestão de pacotes

		application
		model
			entities
			enums
			exceptions
			services

- Declaração import

	A instrução "import" da linguagem Java tem como objetivo disponibilizar em uma classe, de um determinado pacote, o acesso a demais classes que estejam em pacotes diferentes.

	Para isso basta inserir a dealcração "import" após a declaração "package" da classe, exemplo:

	import <caminho fqdn da classe>;

	import java.util.Locale;

- Modificadores de acesso

	Temos quatro modificadores de acesso básicos da linguagem Java: public, private, protected e default.

	Eles servem para tornar componentes da sua aplicação mais ou menos acessíveis por outras partes do seu programa.

	Resumo dos modificadores:

		public: o membro é acessado por todas classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)

		private: o membro só pode ser acessado na própria classe

		protected: o membro só pode ser acessado no mesmo pacote, bem como em subclasses de pacotes diferentes

		(default): o membro só pode ser acessado nas classes do mesmo pacote		

	Detalhes dos modificadores:

	"public"

	Não impõe restrições de acesso ao item, deixando-o visível para todo e qualquer classe. Esse modificador pode ser aplicado sobre todos os itens:

	    Classes
	    Classes internas
	    Interfaces
	    Interfaces internas
	    Annotations
	    Annotations internas
	    Enum
	    Enums internos
	    Métodos
	    Atributos

	"private"

	O modificador que mais restringe a visibilidade do item marcado deixando-o visível somente para a classe que o definiu. Em uma herança a restrição de acesso atinge também as classes filhas, impedindo-as de acessarem o item sob o modificador private. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"protected"

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes filhas da classe que possui o item e para classes que se encontram sob o mesmo pacote da classe que possui o item. Esse modificador pode ser aplicado sobre os itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"default":

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes que se encontram sob o mesmo pacote da classe que possui o item. Em uma herança a restrição de acesso atinge também as classes filhas que não estejam no mesmo pacote, impedindo-as de acessarem o item sob o modificador default.

	Para esse modificador não há uma palavra chave definida para o uso aqui. O modificador aqui é a omissão dos outros modificadores. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes
	    Classes internas
	    Interfaces internas
	    Annotations  internas
	    Enums internos
	    Métodos
	    Atributos

    Visibilidade de um item com o modificador de acesso

	Para testar a visibilidade de um item com o seu modificador de acesso há cinco cenários diferentes:

    A partir da mesma classe
    Qualquer classe no mesmo package
    Qualquer classe filha no mesmo package
    Qualquer classe filha em package diferente
    Qualquer classe em package diferente

    Para isso utilizamos a tabela abaixo:

	Visibilidade 									public 		protected 		default 	private

    A partir da mesma classe 						OK			OK 				OK 			OK
    Qualquer classe no mesmo package 				OK			OK 				OK 			Não
    Qualquer classe filha no mesmo package 			OK			OK 				OK 			Não
    Qualquer classe filha em package diferente 		OK			OK 				Não 		Não
    Qualquer classe em package diferente 			OK			Não 			Não 		Não

- Atributos

	Os atributos são as propriedades de uma classe, também são conhecidos como variáveis ou campos. Essas propriedades definem o estado de um objeto, fazendo com que esses valores possam sofrer alterações.

	Eles são declarados como variaveis comuns porpém dentro da classe.

	Exemplo:

	int idade;

- Referência "this"

	É uma referenci apara o proprio objeto.

	Usos comuns:

	Diferenciar atributos de variáveis locais
	Passar o próprio objeto como argumento na chamada de um método ou construtor

	Por exemplo, caso algum atributo tenha o mesmo nome de um parâmetro de método  (normalmente no método construtor) podemos referenciar o atributo do objeto com a palavra "this" antes do atributo ao utilizar o mesmo.

	Exemplo:

	this.<nome do atributo>

	this.quantidade = quantidade;

- Métodos

	Representam um processamento que possui um significado.

	As principais vantagens: modularização, delegação e reaproveitamento de código.

	Dados de entrada e saída:

	Funções podem receber dados de entrada (parâmetros)
	Funções podem ou não retornar uma saída

	Estrutura:

	<modificador de acesso> <propriedade de instanciação se necessário> <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	Exemplo:

	public static int max(int x, int y, int z) {

		int maxNumber;

		if (x > y && x > z) {
			maxNumber = x;
		} else if (y > x && y > z) {
			maxNumber = y;
		} else {
			maxNumber = z;
		}

		return maxNumber;
	}

- Método "main"

	É o primeiro método executado em um programa Java, considerado como o "entry-point" da aplicação.

	Normalmente ele está na classe "Program".

	Ele deve ser declarado sempre da mesma forma:

	public static void main(String[] args) {
		<código do método>
	}

- Objeto

	Uma classe é como se fosse uma planta de uma casa, um  desenho, um projeto de algo. Não podemos utilizar uma planta de uma casa para morar, precisamos contruir a casa.

	Desta forma um objeto é como se fosse a casa construida a partir da planta.

	A classe tem a descrição do que o objeto possui e faz, mas é somente um projeto, para utilizarmos a classe criamos onjetos baseados nela.

- Declaração e instanciação de um objeto

	Para criarmos um objeto temos dois passos, a declaração e a instanciação.

	A declaração de um objeto é feito igual a uma variavel comum.

	Exemplo:

	<nome da classe> <nome do objeto>;

	Triangulo t;

	Ela cria na memória uma variável com conteúdo vazio.

	Instanciar é o ato de criar o objeto na memória e inserir seu endereço dentro da variavel criada anteriormente.

	Exemplo:

	<nome do objeto> = new <nome da classe>(<paramentros se necessario):

	t = new Triangulo(2.00, 3.00, 5.00);

	Uma variavel do tipo comum (primitiva) guarda dentro dela o valor propriamente dito, ja uma variavel do tipo objeto guarda um valor de enderço de memoria que redireciona a variavel (como um link ou ponteiro) ao local onde os dados efetivamente estao.

- Linguagem UML

	A Linguagem de Modelagem Unificada (UML) foi criada para estabelecer uma linguagem de modelagem visual comum, semanticamente e sintaticamente rica, para arquitetura, design e implementação de sistemas de software complexos, tanto estruturalmente quanto para comportamentos.

	A UML não é uma linguagem de programação, ela mostra as classes (com seus atributos e métodos) e seus relacionamentos com outras classes, tudo em forma de desenho.

	Podemos dizer que a UML mostra o projeto da classe ou diagrama de classes.

- Diagrama de classe UML

	-------------------------
	| <nome da classe>      |
	-------------------------
	| <atributos da classe> |
	-------------------------
	| <métodos da classe>   |
	-------------------------

	Exemplo:

	-----------------------------------------
	|               Triangle                |
	-----------------------------------------
	| - A: double                           |
	| - B: double                           |
	| - C: double                           |
	-----------------------------------------
	| + area(X: double, Y: double): double  |
	-----------------------------------------

	Detalhes:

	O nome da classe é escrito em negrito e com alinhamento centralizado.

	Temos modificadores de acesso igual ao Java:

	"-" para private
	"#" para protected
	"+" para public
	"~" para default

	Os atributos possuem alinhamento a esquerda na seguinte estrutura:

	"<modificador de acesso> <nome da variavel>: <tipo da variavel>"

	Os métodos possuem alinhamento a esquerda na seguinte estrutura:

	"<modificador de acesso> <nome do método>(<nome do parametro>: <tipo do parametro>): <tipo da variavel de retorno>"

- Diagrama UML para ENUM

	-------------------------
	| <<enum>>              |
	| <nome da enum>        |
	-------------------------
	| <constantes da enum>  |
	-------------------------
	|                       |
	-------------------------

	Exemplo:

	-----------------------------------------
	|               <<enum>>                |
	|              OrderStatus              |
	-----------------------------------------
	| - PENDING_PAYMENT: int = 0            |
	| - PROCESSING: int = 1                 |
	| - DELIVERED: int = 2                  |
	-----------------------------------------
	|                                       |
	-----------------------------------------

	Detalhes:

	Inicialmente colocamos a descrição "<<enum>>"

	O nome da enum é escrito em negrito e com alinhamento centralizado.

	É utiliado o indicador "private" para cada constante.

	As constantes possuem alinhamento a esquerda na seguinte estrutura:

	"<modificador de acesso> <nome da constante em maiusculo>: int = <valor de posição>"

- Conectores UML

	Associação (conector sem pontas) - É um tipo de relacionamento usado entre classes. Aplicável a classes que são independentes (vivem sem dependência umas das outras), mas que em algum momento no ciclo de vida do software (enquanto ele está em execução) podem ter alguma relação conceitual.

	Herança (conector com seta em uma das pontas) - É um tipo de relacionamento onde a classe generalizada (onde a "ponta da seta" do conector fica) fornece recursos para a classe especializada (herdeira). Excetuando conceitos mais avançados (como padrões de projeto, interfaces, visibilidades específicas etc.), tudo que a classe mãe (generalizada) tem, a filha (especializada) terá.

	Composição (conector com um "diamante" hachurado na ponta) - É um tipo de relacionamento onde a classe composta depende de outras classes para "existir". Por exemplo, a classe "CorpoHumano" possui um composição com a classe "Coracao". Sem a classe "Coracao", a classe "CorpoHumano" não pode existir.

	Agregação (conector com um "diamante" vazado na ponta) - É um tipo de relacionamento onde a classe agregada usa outra classes para "existir", mas pode viver sem ela. Por exemplo, a classe "CorpoHumano" possui uma agregação com a classe "Mao". Sem a "Mao" a classe "CorpoHumano" pode existir.

- Classe "Object"

	Toda classe em Java é uma subclasse da classe "Object".

	Object possui os seguintes métodos:

	getClass()- retorna o tipo do objeto
	equals() - compara se o objeto é igual a outro
	hashCode() - retorna um código hash do objeto
	toString() - converte o objeto para string

- Método "toString()"

	Ao tentar imprimir um objeto diretamente no console recebemos como resultado o nome do pacote e classe ao qual o objeto pertence, assim como seu endereço de memória.

	Exemplo:

	entities.Product@6108b2d7

	Esta informação não tem muita utilidade.

	Caso seja necessario retornar informações relativas a atributos e métodos do objeto como uma String devemos utilizar o método "toString()".

	Este método existe na classe pai "Object" e é herdada por todos os objetos em Java, desta forma a implementação feita em "Object" retorna o exemplo citado acima.

	Podemos reescrever este método em nossas classes, retornando dentro dele como gostariamos que o objeto fosse impresso em um console.

	Para isso utilizamos a estrutura abaixo:

	@Override
	public String toString() {
		return <dados a serem exibidos do objeto>
	}

	Exemplo:

	@Override
	public String toString() {
		return name + ", " + quantity;
	}

	O "@Override" serve para mostrar que este método esta reescrevendo um método ja definido em uma classe pai.

- Método "String.format()"

	Utilizado para aplicar formatação similar ao "printf" em uma String.

	Exemplo:

	return name + ", " + String.format("%.2f", quantity);

	Normalmente é utilizada junto ao método "toString()".

- Membros de instancia

	Uma classe possui membros, esses membros são os atributos e os métodos.

	Ao criar e instanciar um objeto cada um irá possuir uma cópia (instancia) dos membros, estes membros são chamados de "membro de intancia" ou "menbros de objeto".

	Cada objeto conhece somente os seus membros, membros de outros objetos (mesmo sendo da mesma classe) não são conhecidos.

- Membros estaticos

	Também chamados membros de classe em oposição a membros de instância.

	São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe.

	Exemplo:

	Math.sqrt

	Não precisamos instanciar um objeto da classe Math para utiliza-la, basta chamamos seus métodos de forma direta.

	Aplicações comuns:

	Classes utilitárias
	Declaração de constantes

	Uma classe que possui somente membros estáticos, pode ser uma classe estática também. Esta classe não poderá ser instanciada.

	Para declarar um mebro estatico basta inserir a palavra "static" em sua declaração.

	Exemplo:

	Atributos:

	public static <tipo da variavel> <nome da variável> = <valor da variável>;

	public static double pi = 3.14159;
	
	Métodos:

	<modificador de acesso> static <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	public static double volume(double radius) {
		return (4.0 * PI * Math.pow(radius, 3)) / 3;
	}

- Constantes

	Uma constante é um tipo especial de variável cujo valor, uma vez definido no código, não pode mais ser alterado durante a execução do programa.

	Declaramos uma constante em Java usando a palavra-chave final.
	
	Exemplo:

	public static final double PI = 3.14159;

	Declarar sempre uma constante usando apenas letras maiúsculas, e em caso de palavras compostas, separá-las com um underline (_).

- Construtores

	É uma operação especial da classe, que executa no momento da instanciação do objeto.

	Usos comuns:

	Iniciar valores dos atributos
	Permitir ou obrigar que o objeto receba dados / dependências no momento de sua instanciação (injeção de dependência)

	Se um construtor customizado não for especificado, a classe disponibiliza o construtor vazio (default) que instacia o objeto com valores padrão de cada tipo.

	Valores padrão:

	Descrição 								Valor padrão

	tipos numéricos inteiros				0
	tipos numéricos com ponto flutuante		0.0
	tipo char 			 					'\u0000' (null)
	tipo boolean 							false
	tipo object 							null

	Também é possível especificar mais de um construtor na mesma classe (sobrecarga).

	Declaração:

	Construtor vazio (default)

		Basta não declarar nenhum método construtor na classe e instaciar a mesma passando sem passar nenhum argumento entre os parenteses, por exemplo:

		Product p = new Product();

		Desta forma os atributos do objeto serão inicializados com o valor padrão para cada tipo.

		Atenção, o construtor vazio so funciona se não existir nenhu outro construtor dentro da classe, caso exista algum construtor o mesmo deve ser utilziado e instanciar um objeto sem parametros resultara em erro.

	Contrutor padrão

		Para criarmos um contrutor padrão devemos criar um método dentro da classe que será instanciada, o método possuirá o nome da propria classe, seguindo a estrutura abaixo:

		<public <nome da classe>(<parametros>) {
			this.Nome do atributo interno da classe> = <parametro>...
		}

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = quantity;
		}

		Caso algum atributo necessite ser iniciado com valor especifico podemos colocar dentro do construtor tambem, por exemplo:

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = 0;
		}

- Sobrecarga de métodos

	É um recurso que uma classe possui de oferecer mais de uma método com o mesmo nome, porém com diferentes listas de parâmetros.

	Pode ser utilizado em métodos comuns e em construtores.

	Segue exemplo com construtores:

	// Construtor com valores default
	public Product() {
	}
	
	// Construtor recebendo os 3 parametros
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	// Construtor recebendo 2 parametros e um com valor default
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}

- Encapsulamento

	É um princípio que consiste em esconder detalhes de implementação de uma classe, expondo apenas operações seguras e que mantenham os objetos em um estado consistente.

	O objeto deve sempre estar em um estado consistente, e a própria classe deve garantir isso.

	Regra geral básica:

	Um objeto NÃO deve expor nenhum atributo (atributos devem ter modificador de acesso private)
	Os atributos devem ser acessados por meio de métodos get e set

	Padrão para implementação de métodos getters e setters

	O método get é utilizado para recuperar o valor do atributo, exemplo de declaração:

	public <tipo de retorno> get<nome do atributo>() {
		return <atributo>;
	}

	public String getName() {
		return name;
	}

	O método set é utilizado para configurar o valor do atributo, exemplo de declaração:

	public void set<nome do atributo>(<tipo do parametro> <parametro>) {
		this.<nome do atributo> = <parametro>;
	}

	public void setName(String name) {
		this.name = name;
	}

- Área de memória Heap e Stack

	O sistema operacional ao carregar um programa na memória  disponibiliza ao programa um espaço de endereçamento, esse espaço é a memória disponível para aquele programa.

	O Heap, ou área de alocação dinâmica, é um espaço reservado para variáveis e dados criados durante a execução do programa. Vamos dizer que o Heap é a memória global do programa.

	O Stack é uma área da memória que aloca dados, variáveis ou ponteiros quando uma função é chamada e desalocada quando a função termina. Podemos dizer então que representa a memória local àquela função. 

- Variáveis tipos valor (primitivos) vs tipos referência (classes)

	Variáveis tipos valor (primitivos) são criados na área Stack, são como se fossem caixas que guardam exatamente o valor que for atribuido a variável, por exemplo, se atribuirmos o valor 1 a variável teremos o valor 1 dentro da caixa.

	Variáveis Tipos referência (classes) são criados inicialmente na área Stack, são como se fossem caixas assim como os tipos primitivos, mas diferente deles as caixas não guardam os valores atribuidos a variável e sim um valor de memória que aponta para um local na área Heap. Neste local da area Heap teremos uma caixa que irá guardar os valores do objeto. Funcionando como um ponteiro.

	Tabela comparativa:

	Classe																					Tipo Primitivo

	Vantagem: usufrui de todos recursos OO 													Vantagem: é mais simples e mais performático
	Variáveis são ponteiros 																Variáveis são caixas
	Objetos precisam ser instanciados ou apontar para um objeto já existente. 				Não instancia. Uma vez declarados, estão prontos para uso.
	Aceita valor null 																		Não aceita valor null
	Y = X; "Y passa a apontar para onde X aponta" 											Y = X; "Y recebe uma cópia de X"
	Objetos instanciados no heap 															Variaveis são criadas no stack
	Objetos não utilizados são desalocados em um momento próximo pelo garbage collector 	Variaveis são desalocados imediatamente quando seu escopo de execução é finalizado

- Garbage collector

	É um processo que automatiza o gerenciamento de memória de um programa em execução.

	O garbage collector monitora os objetos alocados dinamicamente pelo programa (no heap), desalocando aqueles que não estão mais sendo utilizados (não possuem mais ponteiros apontando para eles).

- Desalocação por garbage collector e por escopo

	A desalocação por garbage collector é feita automaticamente, sem intervenção do usuário, de tempos em tempos. Funciona para tipos referencias (classes).

	A desalocação por escopo é feita assim que o escopo onde a variável foi criada é encerrado, pode ser um método, uma estrutura de repetição ou de seleção. Funciona para tipos valor (primitivos).

- Vetor (array)

	Vetor (array) é o nome dado a arranjos unidimensionais.

	Vetor é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo do vetor>[] <nome da variavel>;

		double[] number;

	Instanciação:

		<nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		number = new double[3];

	Declaração e instanciação na mesma linha:

		<tipo do vetor>[] <nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		double[] number = new double[3];

	Atributos de um vetor:

		length - mostra o tamanho do vetor

- Boxing, unboxing e wrapper classes

	Boxing

		É o processo de conversão de um objeto tipo valor (primitivo) para um objeto tipo referência compatível, exemplo:

		int x = 20;
		Object obj = x;

	Unboxing:

		É o processo de conversão de um objeto tipo referência para um objeto tipo valor compatível, exemplo:

		int x = 20;
		Object obj = x;
		int y = (int) obj;

		O processo de Boxing é feito de forma implicita, já o processo de Unboxing é feito de forma explicita (com casting).

	Wrapper classes

		Para facilitar o processo de Boxing e Unboxing foram criadas as wrapper classes, elas são classes equivalentes aos tipos primitivos, segue tabela:

		Tipo primitivo 			Wrapper classes

		byte					Byte
		short					Short
		int						Integer
		long					Long
		float					Float
		double					Double
		char					Character
		boolean					Boolean

		Uso comum: campos de entidades em sistemas de informação, pois tipos referência (classes) aceitam valor null e usufruem dos recursos OO.

		Atributos de classes devem ser declarados como Wrapper classes para boa prática, exemplo:

		public class Product {
			private String name;
			private Double price;
			private Integer quantity;
			(...)

		A wrappers classes podem ser utilizadas como se fosse um tipo primitivo normalmente, inclusive em calculos, exemplo:

		Integer x = 10;
		int y = x * 2;

- Laço "for each"

	Sintaxe opcional e simplificada para percorrer coleções.

	Ela serve somente para exibição, não serve para modificar os valores dos itens das coleções.

	Sintaxe:

	for (<tipo da coleção> <variavel interna do laço> : <variavel da coleção>) {
		<comandos a serem executados>
	}

	Exemplo:

	String[] vect = new String[] {"Bolacha", "Minhoca", "Gabriel"};
	
	for (String nome : vect) {
		System.out.println(nome);
	}

- Listas

	Lista é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Inicia vazia, e seus elementos são alocados sob demanda
		Cada elemento ocupa um "nó" (ou nodo) da lista
		Não aceita tipos primitivos, somente classes

	Seu tipo é o "List".

	Podemos declarar um tipo como "List" porem não podemos instanciar devido a ser uma interface, a instanciação deve ser feita em uma de suas implementações.

	Seguem algumas classes que implementam "List":

		AbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector

	Vantagens:

		Tamanho variável
		Facilidade para se realizar inserções e deleções

	Desvantagens:

		Acesso sequencial aos elementos

	Declaração:

		List<tipo a ser guardado> <nome da lista> = new <implementação da lista><>();

		List<String> list = new ArrayList<>();

	Métodos:

		size() - mostra o tamanho da lista
		add(<elemento>) - adicionar elemento na ultima posição
		add(<posição>, <elemento>) - adicionar elemento na posição desejada
		remove(<elemento ou posição>) - remover elemento da lista
		get(<posição>) - obter o elemento da posição
		indexOf(<elemento>) - busca o primeiro elemento na lista com o valor desejado
		indexOf(<elemento>) - busca o ultimo elemento na lista com o valor desejado

- Matrizes

	Matriz é o nome dado a arranjos bidimensionais.

	Matriz é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo da matriz>[][] <nome da variavel>;

		double[][] number;

	Instanciação:

		<nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		number = new double[2][3];

	Declaração e instanciação na mesma linha:

		<tipo da matriz>[][] <nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		double[][] number = new double[2][3];

	Atributos de um vetor:

		length - mostra o tamanho de linhas ou colunas da matriz

- Datas

	Classe "Date"

		Para datas em Java utilizamos a classe "Date", ela faz parte do pacote "java.util".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.util.Date;

		Um objeto Date internamente armazena o número de milissegundos (tipo long) desde a meia noite do dia 1 de janeiro de 1970 (UTC - timezone GMT).

		A prática comum é salvar sempre as datas no formato UTC e efetuar a conversão para leitura / gravação conforme o timezone local.

		Exemplo de declaração:

		Date <nome da variável>;

		Podemos instanciar uma data de vária formas, por exemplo:

		new Date() - momento atual
		new Date(System.currentTimeMillis()) - momento atual
		new Date(<tempo em milisegundos>L) - momento que usa como referência os milisegundos a partir de "1 de janeiro de 1970 00:00:00"

		Mas o mais comum é instanciar um objeto Date partindo de uma data em String, para isso utilizamos uma classe de formatação de datas, a classe "SimpleDateFormat".

	Classe "SimpleDateFormat"

		Para formatação de datas utilizamos a classe "SimpleDateFormat", ela faz parte do pacote "java.text".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.text.SimpleDateFormat;

		Essa classe define formatos (máscaras) para conversão entre Date e String, seu uso principal é para instanciar um objeto Date a partir de uma data em String ou para exibir um objeto Date em um formato específico.

		Exemplo de declaração:

		SimpleDateFormat sdf;

		Exemplo de instanciação:

		sdf = new SimpleDateFormat("<mascara>");

		Podemos instanciar com diversas máscaras, por exemplo:

		"dd/MM/yyyy"                   - 23/07/2018
		"dd/MM/yyyy HH:mm:ss"          - 23/07/2018 15:42:07
		"yyyy.MM.dd G 'at' HH:mm:ss z" - 2001.07.04 AD at 12:08:56 PDT
		"EEE, MMM d, ''yy"             - Wed, Jul 4, '01
		"h:mm a"                       - 12:08 PM
		"hh 'o''clock' a, zzzz"        - 12 o'clock PM, Pacific Daylight Time
		"K:mm a, z"                    - 0:08 PM, PDT
		"yyyyy.MMMMM.dd GGG hh:mm aaa" - 02001.July.04 AD 12:08 PM
		"EEE, d MMM yyyy HH:mm:ss Z"   - Wed, 4 Jul 2001 12:08:56 -0700
		"yyMMddHHmmssZ"                - 010704120856-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSZ"   - 2001-07-04T12:08:56.235-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSXXX" - 2001-07-04T12:08:56.235-07:00
		"YYYY-'W'ww-u"                 - 2001-W27-3

		As máscaras são criadas a partir da tabela abaixo:

		Letter 		Date or Time Component 									Presentation 				Examples

		G 			Era designator 											Text 						AD
		y 			Year 													Year 						1996; 96
		Y 			Week year 												Year 						2009; 09
		M 			Month in year 											Month 						July; Jul; 07
		w 			Week in year 											Number 						27
		W 			Week in month 											Number 						2
		D 			Day in year 											Number 						189
		d 			Day in month 											Number 						10
		F 			Day of week in month 									Number 						2
		E 			Day name in week 										Text 						Tuesday; Tue
		u 			Day number of week (1 = Monday, ..., 7 = Sunday) 		Number 						1
		a 			Am/pm marker 											Text 						PM
		H 			Hour in day (0-23) 										Number 						0
		k 			Hour in day (1-24) 										Number 						24
		K 			Hour in am/pm (0-11) 									Number 						0
		h 			Hour in am/pm (1-12) 									Number 						12
		m 			Minute in hour 											Number 						30
		s 			Second in minute 										Number 						55
		S 			Millisecond 											Number 						978
		z 			Time zone 												General time zone 			Pacific Standard Time; PST; GMT-08:00
		Z 			Time zone 												RFC 822 time zone 			-0800
		X 			Time zone 												ISO 8601 time zone 			-08; -0800; -08:00

		Criando um objeto Date:

		Utilizamos o método "parse" para transformar o texto em um objeto Date, por exemplo:

		Date date = sdf.parse("23/07/2018");

		Imprimindo um objeto Date:

		Utilizamos o método "format" para imprimir um objeto Date, por exemplo:

		System.out.println(sdf.format(data));

		Por padrão é utilizado o timezone local da máquina, para alterarmos devemos definir a configuração em um objeto "SimpleDateFormat" conforme abaixo:

		sdf.setTimeZone(TimeZone.getTimeZone("<timezone desejado>"));

		Por exemplo, timezone "GMT":

		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));

		Esta alteração necessita do import da classe "java.util.TimeZone";

	Classe "Instant"

		A partir do Java versão 8 foram criadas novas classes para tratamento de datas, uma delas é a classe Instant.

		Éla é utilizada para transformar uma data texto no formato ISO 8601 (UTC) em objeto "Date".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.time.Instant;

		O padrao utilizado para gravação de datas é o ISO 8601 que compreende o seguinte formato:

		yyyy-MM-ddTHH:mm:ssZ

		Exemplo:

		2018-06-25T15:42:07Z

		Utilizamos o seguinte modo de conversão:

		Date <nome da variável> = Date.from(Instant.parse("<data no formato texto ISO 8601"));

		Exemplo:

		Date date = Date.from(Instant.parse("2018-06-25T15:42:07Z"));

	Classe "Calendar"

		Para pegarmos informação especifica de uma data ou efetuarmos calculos com datas utilizamos a classe "Calendar", ela faz parte do pacote "java.util".

		Desta forma para utilza-la devemos importar a classe da seguinte forma:

		import java.util.calendar;

		Exemplo de declaração / instanciação:

		Calendar cal = Calendar.getInstance();

		Temos diversos usos para esa classe.

		Atribuindo uma data ao calendario:

		cal.setTime(<objeto Date>);

		Atribuindo uma data de calendário para um objeto Date:

		<objeto Date> = cal.getTime();

		Adicionando ou subtraindo tempo a data do calendario:

		cal.add(<o que será atribuido (verificar na documentação)>, <quantidade a ser atribuida ou subtraida com valor negativo>);

- Git e Github

	GIT - é um sistema de versionamento: você controla as modificações de um projeto por meio de versões chamadas "commits".

		Um projeto controlado pelo Git é chamado de repositório de versionamento. Tipicamente uma cópia "oficial" do repositório fica salvo em um servidor (repositório remoto). Cada pessoa que trabalha no projeto pode fazer uma cópia do repositório para seu computador (repositório local). A pessoa então faz suas alterações no projeto (novos commits) e depois salva as alterações no servidor.

		Operações principais:

		CLONE  - Copia o repositório remoto para seu computador
		PULL   - Atualiza seu repositório local em relação ao repositório remoto
		COMMIT - Salva uma nova versão (tipicamente no seu repositório local)
		PUSH   - Envia o repositório local para o repositório remoto

		O Git pode ser usado por ou por terminal de comando, ou por um aplicativo gráfico.

	GITHUB - é um serviço de hospedagem de repositórios Git remotos.

		Caracteristicas:

		Possui uma interface gráfica web: github.com
		É uma plataforma social (usuários, página de perfil, seguidores, colaboração, etc.). Dica: currículo!
		Maior serviço do mundo de hospedagem de projetos de código aberto
		Modelo de cobrança: gratuito para projetos de código aberto, pago para projetos privados
		Alternativas: BitBucket, GitLab, etc.

	Instalação do GIT

		Opções recomendadas:

		Use Vim as Git's default editor
		Use Git from the Windows Command Prompt
		Use the OpenSSL library
		Checkout Windows-style, commit Unity-style line endings
		Use MinTTY
		DESMARCAR: Enable Git Credential Manager

		É recomendado configurar o Windows para exibir os arquivos ocultos e a extensão dos arquivos para facilitar o uso do Git.

	Configurar usuário do GIT

		git config --list
		git config --global user.name "<nome do usuário>"
		git config --global user.email "<email do usuário>"
		git config --list

	Arquivo .gitignore

		Para quê serve o arquivo .gitignore?

		Serve para informar o GIT quais arquivos devem ser ignorados no sincronismo, isso faz com que arquivos d elog ou compilados por exemplo nao sejam enviados ao Github. Isso econimiza tempo no sincronismo e espaço no projeto.

		Como saber o que colocar no arquivo .gitignore?

		Normalmente ao criar um projeto no Github temos um campo para selecionar um template para o .gitignore, podemos utilizar o mesmo sem problema e ir adequando posteriormente caso necessário.

		Mas voce pode criar um arquivo .gitignore manualmente no projeto  e inserir os arquivos e extensões de arquivos que quiser.

	Criar um novo projeto

		Passos:

		1. Crie um novo projeto no seu ambiente de desenvolvimento

		2. Crie um novo repositório no Github
		ATENÇÃO: se seu ambiente de desenvolvimento não gera o arquivo .gitignore automaticamente, escolha o seu tipo desejado de .gitignore na tela de criação de repositório do Github

		3. Abra um terminal na pasta do seu projeto

		4. IMPORTANTE: certifique-se de estar identificado no Git do seu computador (nome e email) executando os comandos de configuração de usuário
		
		5. Faça os comandos a seguir

		- Inicia um novo repositório local na pasta do seu projeto
		git init

		- Altera o nome da branch de "master" para "main" (novo padrão do Git)
		git branch -M main

		-Associa seu repositório local ao repositório remoto, com o apelido de "origin"
		ATENÇÃO: troque pelo caminho do seu repositório do Github
		git remote add origin https://github.com/acenelio/<URL do meu projeto>.git

		- Atualiza seu repositório local em relação ao repositório remoto
		ATENÇÃO: este comando só é necessário se você criou o .gitignore pelo Github
		git pull origin master

		- Verifica arquivos
		git status

		- Adiciona todos arquivos ao stage
		git add .

		- Salva uma nova versão do projeto
		git commit -m "<mensagem de commit>"

		- Envia o repositório local para o repositório remoto
		ATENÇÃO: nas próximas vezes basta fazer: git push
		git push -u origin master

	Salvando uma nova versão

		Passos:

		- Verifica status dos arquivos
		git status

		- Adiciona todos arquivos ao stage
		git add .

		- Salva uma nova versão do projeto
		git commit -m "<mensagem de commit>"

		- Envia o repositório local para o repositório remoto
		git push

	Trabalhando (clonando) um projeto existente

		Passos:

		1 - Clonar o repositório do Github

		git clone <URL do projeto>

		2 - Importar o projeto no programa editor

		3 - Altere o que você precisar no projeto

		4 - Commitar as mudanças feitas no projeto

		git status
		git add .
		git commit -m "<mensagem de commit>"
		git log --oneline

		5 - Salvar projeto atualizado no seu Github

		git push

	Verificando o histórico de versões

		Para log mais completo executar "git log"

		Para log mais simples executar "git log --oneline"

	Status dos arquivos

		untracked - arquivos novos
		modifief - arquivos ja comitados anteriormente que foram modificados
		deleted - arquivos ja comitados anteriormente que foram excluidos

	A sequência de commits deve ser respeitada

		Sempre execute o omando "git pull" para sincronizar seu repositorio local antes de editar o codigo e antes de executar um commit.

		Caso seu repositorio local esteja diferente do remoto e voce tente efetuar um comando git push será apresentado erro.

	Git checkout

		Permite modificar temporariamente os arquivos do projeto ao estado de um dado commit ou branch

		Código do commit, HEAD:

		Cada commit possui um código, que pode ser utilizado para referenciar o commit
		O último commit do histórico do branch corrente também pode ser referenciado pela palavra HEAD
		É possível referenciar um commit N versões antes de HEAD usando ~N, por exemplo:
		HEAD~1 (penúltimo commit)
		HEAD~2 (antepenúltimo commit)

		IMPORTANTE: antes de fazer o checkout para voltar para HEAD, certifique-se de que não haja mudanças nos arquivos. Se você acidentalmente mudou alguma coisa, desfaça as modificações usando:

		git reset
		git clean -df
		git checkout -- .

	Como resolver push rejeitado

		Não é permitido enviar um push se seu repositório local está diferente em relação ao histórico do repositório remoto.

		Para evitar isso sempre execute o comando "git pull" antes de iniciar seu trabalho e antes de efetuar o commit.

		Mas caso o problema ocorra ao tentar efetuar o push é necessário efetuar uma ação de integração.

		Caso os arquivos modificados nao sejam os mesmos entre o repo remoto e local sera feito um merge automatico do repo remoto com o local, gerando um commit automatico, resolvendo assim o problema e permitindo a execução do pull.

		Será aberta uma tela do Vim para inserção da mensagem de commit, podemos deixar a mensagem padrão e salvar / sair.

		Mas caso os arquivos modificados sejam os mesmos entre o repo remoto e local não sera feito um merge automatico, teremos de atuar manualmente na correção / merge dos arquivos.

		Após tentar a execução do pull e a falha ser apresentada, o Git entra em modo merge manual, executando o comando git status é informado qual arquivo esta com conflito.

		Abrindo este arquivo no editor o Git irá inserir automaticamente (junto do código do commit) todas as informações no arquivo.

		Devemos editar o arquivo, deixar da forma correta e efetuar um novo processo de commit / pull.

	Kit de primeiros socorros

		Problema 																					Comando

		Duvida em relação ao conteudo do arquivo 													git diff

		Remover arquivos da area de stage 															git reset

		Quero desfazer tudo que eu fiz desde o último commit 										git reset
																									git clean -df
																									git checkout -- .

		Preciso remover o último commit, porém mantendo os arquivos do jeito que estão 				git reset --soft HEAD~1

		Preciso remover qualquer commit, porém mantendo os arquivos do jeito que estão 				git reset --soft <código do commit>

		Preciso remover o último commit, inclusive as alterações nos arquivos						git reset --hard HEAD~1

		Preciso remover qualquer commit, inclusive as alterações nos arquivos						git reset --hard <código do commit>

		Quero alterar temporariamente os arquivos do projeto 										git checkout <código do commit>
		de modo a ficarem no estado do commit informado
		ATENÇÃO: não podem haver modificações não commitadas no projeto
		NOTA: para voltar ao último commit faça: 													git checkout master

		Preciso apagar o último commit no Github 													git push -f origin HEAD^:master

		Quero mudar o meu repositório remoto "origin" 												git remote set-url origin <URL do projeto>

		Entrei no VIM por engano. Como sair sem salvar? 											Tecle ESC, depois digite :q! e tecle ENTER

		Entrei no VIM por engano. Como sair salvando?	 											Tecle ESC, depois digite :wq! e tecle ENTER

	 	Como atualizar o repositório local em relação ao remoto 									git pull

	 	Como sobrescrever um histórico no Github 													git push -f

- Enumerações

	É um tipo especial que serve para especificar de forma literal um conjunto de constantes relacionadas.

	Palavra chave em Java: enum

	Vantagem: melhor semântica, código mais legível e auxiliado pelo compilador

	Em um caso comum ela é utilizada para substituir uma variavel array de uma classe que contenha caracteristicas de um objeto e essas caracterisiticas são fixas.

	A enums ficam no pacote "entities.enums";

	Ela é declarada da seguinte forma:

		package entities.enums;

		public enum <nome da enum> {
			<itens da enum em letra maiuscula>
			...
		}

	Exemplo:

		package entities.enums;

		public enum OrderStatus {
			PENDING_PAYMENT,
			PROCESSING,
			SHIPPED,
			DELIVERED;
		}

	Para utilizar basta importar a enum e declarar como uma variavel da seguinte forma:

		import entities.enums.<nome da enum>;
		....
		<modificador de acesso> <nome da enum> <nome da variavel>;

	Exemplo:

		import entities.enums.OrderStatus;
		...
		private OrderStatus status;

	O acesso a uma constante da enum é feito da seguinte forma:

		<nome da variavel enum>.<constante>;

	Exemplo:

		status.PENDING_PAYMENT;

	A conversão de String para enum é comum pois os sistemas podem informar os valores como String, devedo ser convertida da seguinte forma:

		<nome da variavel enum>.valueOf("<string>");

		Exemplo:

		status.valueOf("DELIVERED");

- Categorias de classes

	Em um sistema orientado a objetos, de modo geral "tudo" é objeto.

	Por questões de design tais como organização, flexibilidade, reuso, delegação, etc., há várias categorias de classes:

	Entities
	Controllers
	Services
	Views
	Repositories

- Composição de objetos (associações)

	É um tipo de associação que permite que um objeto contenha outro, sendo uma relação "tem-um" ou "tem-vários".

	Temos dois tipos de composição de objetos, "Agregação" e "Composição".

	Na Agregação, a existência do Objeto-Parte faz sentido, mesmo não existindo o Objeto-Todo.

	Na Composição a existência do Objeto-Parte não faz sentido se o Objeto-Todo não existir. 

	Na UML a relação de Agregação é mostrada com um losangulo de preenchimento na cor branca.

	Na UML a relação de Composição é mostrada com um losangulo de preenchimento na cor preta.

	Vantagens:

	Organização (divisão de responsabilidades)
	Coesão
	Flexibilidade
	Reuso

	Nota: embora o símbolo UML para composição (todo-parte) seja o diamante preto, neste contexto estamos chamando de composição qualquer associação tipo "tem-um" e "tem-vários".

	Sempre que tivermos uma composição "tem-varios" utilizamos a classe "List", a variável da mesma não é instanciada no construtor recebendo paramentro, ela é instanciada vazia no construtor.

	Exemplo:

		private List<HourContract> contracts;

		public Worker() {
			this.contracts = new ArrayList<HourContract>();
		}

	Esta mesma variável nao deve ter o método "set" configurado, e sim métodos "add" e "remove".

	Exemplo:

		public void addContract(HourContract contract) {
			contracts.add(contract);
		}
		
		public void removeContract(HourContract contract) {
			contracts.remove(contract);
		}

- Classe "StringBuilder"

	Essa classe permite criar e manipular dados de Strings dinamicamente, ou seja, podem criar variáveis de String modificáveis.

	O significado da classe StringBuilder não tem o mesmo sentido que classe String. Existe uma diferença entre essas classes, veja algumas características.

	Características StringBuilder

	    Armazena caracteres especificados pela sua capacidade, caso ela seja excedida, é aumentada para acomodar os caracteres adicionais
	    Não precisa alocar novos objetos quando realiza uma concatenação
	    Não são sincronizadas
	    Não são seguras para threads

	Uma vantagem sobre a classe String é a concatenação de strings. Pois quando concatena strings com StringBuilder é invocado o método append. Esse método aloca novas strings concatenadas para o mesmo objeto, ou seja, cada vez que concatena strings não são criadas cópias dos objetos como é realizado pelo método concat da classe String, contribuindo para um melhor desempenho do sistema.

	Exemplo de declaração:

		StringBuilder  sb;

	Exemplo de instanciação:

		sb = new StringBuilder();

	Métodos

		append("<text>") - adiciona o texto no final
		toString() - mostra o texto

- Herança

	É um tipo de associação que permite que uma classe herde todos atributos e métodos de outra classe, permitindo seu uso e eliminando a duplicidade de código.

	Na UML a relação de herança é mostrada com uma seta fechada com preenchimento na cor branca.

	Sintaxe de uso

		Ao declarar a subclasse devemos inserir a palavra "extends" e o nome da superclasse a frente, por exemplo:

		public class BusinessAccount extends Account {
		...
		}

	Construtor

		Devemos criar um construtor que contemple os atributos da superclasse e da subclasse.

		Na declaração do método inserimos todos os parametros.

		No inicio do método chamamos o construtor da superclasse com a palavra "super" e em seguida passamos os parametros necessarios do construtor da superclasse.

		Em seguida inicializamos os atributos da subclasse.

		Exemplo:

		public BusinessAccount(Integer number, String holder, Double balance, Double loanLimit) {
			super(number, holder, balance);
			this.loanLimit = loanLimit;
		}

	Definições importantes

		A relação entre a subclasse e a superclasse é "é-um".

		Quando olhamos o diagrama UML da subclasse para a superclasse falamos que é uma generalização, quando olhamos o diagrama UML da superclasse para a subclasse falamos que é uma especialização .

		A classe que recebe a herança é chamada de subclasse e a classe que ofere a herança é a superclasse.

		A aplicação da herança é considerada um extensão da classe original. 

		Herança é uma associação entre classes (e não entre objetos).

		O modificador "private" nos atributos da superclasse impede o acesso direto aos mesmos pela subclasse, temo sduas formas de contornar essa situação, utilizando os métodos geters e setters da classe ou mudando o modificador para "protected".

- Upcasting e downcasting

	Upcasting e downcasting são a conversão entre objetos.

	O uso comum do upcasting e downcasting é o polimorfismo.

	Toda subclasse "é uma" superclasse, o contrario não se aplica.

	Upcasting é a conversão de um ojeto da subclasse para a superclasse, ela é feita de forma implicita pois toda subclasse "é uma" superclasse.

	Exemplo:

		BusinessAccount bacc = new BusinessAccount(1002, "Maria", 0.0, 500.0);
		Account acc = bacc;

	Downcasting é a converção de um ojeto da superclasse para a subclasse, ela é feita de forma explicita porém so pode ser feita se a classe a ser convertida for compativel com a classe que irá receber a variável, pois nenhuma superclasse é uma subclasse, caso contrario sera exibido erro de execução "cannot be cast".

	Exemplo:

		* Permitido

		Account acc = new BusinessAccount(1003, "Bob", 0.0, 200.0); // Variavel "Account" instanciada como "BusinessAccount", sendo compativel a conversão explicita
		BusinessAccount bacc = (BusinessAccount) acc;

		* Erro

		Account acc = new Account(1003, "Bob", 0.0); // Variavel "Account" instanciada como "Account", não, sendo compativel a conversão explicita
		BusinessAccount bacc = (BusinessAccount) acc;

	Palavra "instanceof"

		Antes de efetuar um downcasting e correr o risco de receber uma mensagem de erro podemos comparar se um objeto é compativel utilizando a palavra "instanceof" e uma estrutura "if".

		Exemplo:

		if (acc instanceof BusinessAccount) {
			BusinessAccount bacc = (BusinessAccount) acc;
			...
		}

- Sobreposição / sobrescrita de métodos

	É a reimplementação de um método de uma superclasse na subclasse, com lógica diferente.

	Para utilizar primeiramente inserimos a anotação "@Override", isso facilita a leitura e compreensão do código e avisa ao compilador que o método é uma sobreposição.

	Em seguida basta copiar a assinatura do método original (declaração) e inserir a lógica desejada no mesmo.

	O método "toString" é uma sobreposição por exemplo, ele sobrescreve o método "toString" da classe "Object", inserindo uma lógica diferente.

	Exemplo:

	@override
	public String toString() {
		return ...
	}

- Palavra "super" em sobreposição / sobrescrita de métodos

	É possível chamar a implementação da superclasse na subclasse usando a palavra super, para isso, na sobreposição do método, inserir a palavra "super.<método a ser executado>", por exemplo:

	@Override
	public void withdraw(Double amount) {
		super.withdraw(amount);
		balance -= 2.0;
	}

- Classes e métodos "final"

	Para classes a palavra "final" define que aquela classe não pode ser herdada, a palavra eve ser inserida logo após o modificador de acesso, segue exemplo da declaração:

		public final class <nome da classe> {
		...
		})

	Para métodos a palavra "final" define que aquele método não pode ser sobrescrito, a palavra eve ser inserida logo após o modificador de acesso, segue exemplo da declaração:

		public final void <nome do método>() {
		...
		})

	Uso da palavra "final"

		Segurança, dependendo das regras do negócio, às vezes é desejável garantir que uma classe não seja herdada, ou que um método não seja sobreposto.

		Geralmente convém acrescentar final em métodos sobrepostos, pois sobreposições múltiplas podem ser uma porta de entrada para inconsistências.

		Performance, atributos de tipo de uma classe final são analisados de forma mais rápida em tempo de execução.

- Polimorfismo

	Pilares da OOP:

	Encapsulamento
	Herança
	Polimorfismo

	Em Programação Orientada a Objetos, polimorfismo é recurso que permite que variáveis de um mesmo tipo mais genérico possam apontar para objetos de tipos específicos diferentes, tendo assim comportamentos diferentes conforme cada tipo específico.

	Exemplo:

	Account x = new Account(1020, "Alex", 1000.0); // Variavel do tipo Account instanciada com um tipo Account
	Account y = new SavingsAccount(1023, "Maria", 1000.0, 0.01); // Variavel do tipo Account instanciada com um tipo SavingsAccount

	x.withdraw(50.0); // Irá chamar o método do objeto Account
	y.withdraw(50.0); // Irá chamar o método do objeto SavingsAccount

	Importante entender que a associação do tipo específico com o tipo genérico é feita em tempo de execução (upcasting).

- Classes abstratas

	São classes que não podem ser instanciadas.

	É uma forma de garantir herança total, somente subclasses não abstratas podem ser instanciadas, mas nunca a superclasse abstrata.

	Sintaxe:

	Basta acrescentarmos a palavra "abstract" na declaração da classe após o modificador de acesso, exemplo:

		public abstract class <nome da classe> {
			...
		}

	Na notação UML o nome da classe abstrata é escrito em itálico.

	Principai susos de classes abstratas:

	Reuso de código (herança)

	Polimorfismo, a superclasse classe genérica nos permite tratar de forma fácil e uniforme todos os tipos de objetos, inclusive com polimorfismo se for o caso. Por exemplo, você pode colocar todos tipos de objetos em uma mesma coleção.

- Métodos abstratos

	São métodos que não possuem implementação, somente sua ssinatura (declaração).

	Métodos precisam ser abstratos quando a classe é genérica demais para conter sua implementação.

	Se uma classe possuir pelo menos um método abstrato, então esta classe também é abstrata.

	Sintaxe:

	Basta acrescentarmos a palavra "abstract" na declaração do método após o modificador de acesso e removermos as chaves que delimitam o corpo do kmétodo, exemplo:

		public abstract void <nome do método>();

	Na notação UML o nome do método abstrato é escrito em itálico.

- Exceções

	Uma exceção é qualquer condição de erro ou comportamento inesperado encontrado por um programa em execução.

	Em Java, uma exceção é um objeto herdado da classe, segue hierarquia básica:

		java.lang.Throwable
		    java.lang.Exception
		    java.lang.RuntimeException

	Erros da classe "java.lang.Exception" o compilador obriga a tratar ou propagar.

	Erros da classe "java.lang.RuntimeException" compilador não obriga a tratar ou propagar.

	Quando lançada, uma exceção é propagada na pilha de chamadas de métodos em execução, até que seja capturada (tratada) ou o programa seja encerrado.

	Por que exceções?

		O modelo de tratamento de exceções permite que erros sejam tratados de forma consistente e flexível, usando boas práticas.

	Vantagens:

		Delega a lógica do erro para a classe responsável por conhecer as regras que podem ocasionar o erro.
		Trata de forma organizada (inclusive hierárquica) exceções de tipos diferentes.
		A exceção pode carregar dados quaisquer.
		Construtores podem ter tratamento de exceções.
		Possibilidade de auxílio do compilador (Exception).
		Código mais simples. Não há aninhamento de condicionais: a qualquer momento que uma exceção for disparada, a execução é interrompida e cai no bloco catch correspondente.
		É possível capturar inclusive outras exceções de sistema.

	Estrutura "try-catch"

		O bloco "try" contém o código que representa a execução normal do trecho de código que pode acarretar em uma exceção.

		O bloco "catch" contém o código a ser executado caso uma exceção ocorra, devendo ser especificado o tipo da exceção a ser tratada (upcasting é permitido).

		Devemos ter somente um bloco "try" porem podemos ter diversos blocos "catch" associados, cada um capturando uma exceção diferente.

		Sintaxe:

			try {
				<codigo que pode disparar uma exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			...

	Bloco "finally"

		É um bloco que contém código a ser executado independentemente de ter ocorrido ou não uma exceção, ele é sempre colocado ao final da estrutura try-catch.

		Exemplo de uso: fechar um arquivo, conexão de banco de dados, ou outro recurso específico ao final do processamento.

		Sintaxe:

			try {
				<codigo que pode disparar uma exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			...
			finally {
				<código a ser executado independente do resultado das condições anteriores>
			}

	Pilha de chamadas de métodos

		Ao ser lançada uma exceção ela mostra a pilha de chamada de métodos e encerra o programa, por exemplo:

			java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 3
			at application.Program.method2(Program.java:33)
			at application.Program.method1(Program.java:19)
			at application.Program.main(Program.java:11)

		Vemos na sequencia inversa os métodos chamados que implicaram em erro:

			at application.Program.method2(Program.java:33)
			at application.Program.method1(Program.java:19)
			at application.Program.main(Program.java:11)

		Caso a exceção seja capturada, se quisermos podemos ver esta pilha de chamada de métodos, basta chamar o método abaixo na variável que capturou a exceção:

			<variável>.printStackTrace();

		Caso a exceção seja capturada, se quisermos podemos ver esta a mensagem de erro, basta chamar o método abaixo na variável que capturou a exceção:

			<variável>.getMessage();

	Cláusula "throws"

		Propaga a exceção ao invés de tratá-la, é inserida na declaração do método que pode lançar a exceção, por exemplo:

		<declaração do método> throws <exceção que pode ser lançada {
			...
		}

		public void updateDates(Date checkIn, Date checkOut) throws DomainException {
			...
		}

	Cláusula "throw"

		Lança uma exceção, finalizando o método e devolvendo a exceção ao método que o chamou, por exemplo:

		throw new <nome da exceção>("<menagem de exceção>");

		throw new DomainException("Reservation dates for update must be future dates");

	Criação de exceção personalizada

		Podemos criar nossas proprias exceções, para isso basta criar uma classe no pacote "model.exceptions".

		Esta classe deve receber a herança de uma classe de exceção, como "RuntimeException" ou "Exception".

		Em corpo declaramos o "serialVersionUID".

		Em seguida criamos o construtor que recebe uma mensagem String e passa este parametro ao construtor da classe pai.

		Exemplo:

		package model.exceptions;

		public class <nome da exceção a ser criada> extends <nome da exceção que fornecera a herança> {

			private static final long serialVersionUID = <valor>;

			public <nome da exceção a ser criada>(String message) {
				super(message);
			}
			
		}

		Exemplo prático:

		package model.exceptions;

		public class DomainException extends RuntimeException {

			private static final long serialVersionUID = 1L;

			public DomainException(String message) {
				super(message);
			}
			
		}

		Apos a criação da exceção basta importar ela nas classes que forem utiliza-la e lançar a exceção com a clausula "throw".

		Por padrão as classes de exceção possuem a palavra "Exception" em seu nome, por exemplo "DomainException".

	Bloco "try-with-resources"

		É um bloco try que declara um ou mais recursos, e garante que esses recursos serão fechados ao final do bloco, sem a necessidade de fechar em um blco finally.

		Declaração:

			Ao criar o bloco "try" passar como parametros os objetos que devem ser fechados ao final do bloco.

			Exemplo:

			try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			
				String line = br.readLine();
				
				while (line != null) {
					System.out.println(line);
					line = br.readLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			}

		Desta forma evitamos criar um bloco finally que pode lançar exceções, por exemplo:

		} finally {
			
			try {
			
				if (br != null) {
					br.close();
				}
				if (fr != null) {
					fr.close();
				}
			
			} catch (IOException e) {
				e.printStackTrace();
			}
			
		}

- Trabalhando com arquivos e pastas

	Para trabalhar com pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta ou arquivo.

	Gravação e leitura de arquivos

		Lendo os dados do arquivo (com a classe BufferedReader e FileReader, alta performance):

			Para trabalhar com a leitura de arquivos com uma performance maior utilizamos as classes FileReader (stream de leitura de arquivo) e BufferedReader (implementação de leitura de stream de arquivo com melhor performance).

			Utilizamos o método "readLine()" da classe BufferedReader para ler uma linha do arquivo.

			Como fazer:

			Criar um objeto String com o caminho do arquivo.

			Criar um objeto FileReader como "null".

			Criar um objeto BufferedReader como "null".

			Abrir um bloco "try".

			Instanciar o FiledReader passando como parametro a variavel String com o caminho do arquivo.

			Instanciar o BufferedReader passando como parametro o FileReader.

			Criar uma variavel String para ler a primeira linha do arquivo com o método "readLine()" da classe BufferedReader.

			Criar uma estrutura de repetição "while" para ler as linhas do arquivo.

			Dentro da estrutura utilizar o método "readLine()" da classe BufferedReader para ler a proxima linha do arquivo.

			Capturar a exceção IOException.

			Criar um bloco finally.

			Fechar os objetos FileReader e BufferdeReader para liberar o arquivo, porem dentro de outro bloco "try" pois podem lançar exceções.

			Exemplo:

			String path = "C:\\Temp\\in.txt";
			FileReader fr = null;
			BufferedReader br = null;
			
			try {
				
				fr = new FileReader(path);
				br = new BufferedReader(fr);
				
				String line = br.readLine();
				
				while (line != null) {
					System.out.println(line);
					line = br.readLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			} finally {
				
				try {
				
					if (br != null) {
						br.close();
					}
					if (fr != null) {
						fr.close();
					}
				
				} catch (IOException e) {
					e.printStackTrace();
				}
				
			}

		Gravando os dados no arquivo (com a classe BufferedWriter e FileWriter, alta performance):

			Para trabalhar com a gravação de arquivos com uma performance maior utilizamos as classes FileWriter (stream de gravação de arquivo) e BufferedWriter (implementação de gravação de stream de arquivo com melhor performance).

			Utilizamos o método "writeLine()" da classe BufferedWriter para gravar uma linha do arquivo.

			Temos duas opções de instanciação de um FileWriter:

			Cria/recria o arquivo: new FileWriter(<caminho do arquivo>)
			Acrescenta ao arquivo existente: new FileWriter(<caminho do arquivo>, true)

			Como fazer:

			Criar um objeto array de String com os dado a serem gravados.

			Criar um objeto String com o caminho do arquivo que receberá os dados.

			Criar um objeto FileWriter como "null".

			Criar um objeto BufferedWriter como "null".

			Abrir um bloco "try".

			Instanciar o FiledWriter passando como parametro a variavel String com o caminho do arquivo.

			Instanciar o BufferedWriter passando como parametro o FileReader.

			Criar uma estrutura de repetição "for" para ler as linhas do do objeto String criado com os dados.

			Dentro da estrutura gravar a linha lida no arquivo com o método "writeLine()" da classe BufferedWriter.

			A gravação não efetua quebra de linha, sendo necessaria efetuar manualmente com o método "newLine()" da classe BufferedWriter.

			Capturar a exceção IOException.

			Criar um bloco finally.

			Fechar os objetos FileWriter e BufferdeWriter para liberar o arquivo, porem dentro de outro bloco "try" pois podem lançar exceções.

			Exemplo:

			String[] lines = new String[] {"Bom dia", "Boa tarde", "Boa noite"};
			String path = "C:\\temp\\out.txt";
			FileWriter fw = null;
			BufferedWriter bw = null;
			
			try {
				
				fw = new FileWriter(path, true);
				bw = new BufferedWriter(fw);
				
				for (String line : lines) {
					bw.write(line);
					bw.newLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			} finally {
				
				try {
				
					if (bw != null) {
						bw.close();
					}
					if (fw != null) {
						fw.close();
					}
				
				} catch (IOException e) {
					e.printStackTrace();
				}
				
			}

	Gravação e leitura de pastas

		Listar pastas / arquivos

			Para listar pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta, especificamente seu método "listFiles()".

			Para mostrar as pastas passamos o parametro "File::isDirectory" ao método.

			Para mostrar os arquivos passamos o parametro "File::isFile" ao método.

			Para mostrar os arquivos e pastas basta não passar nenhum parametro ao método.

			Exemplo:

				Scanner sc = new Scanner(System.in);
		
				System.out.print("Enter a folder path: ");
				String folderPath = sc.nextLine();
				
				File path = new File(folderPath);
				
				File[] folders = path.listFiles(File::isDirectory);
				System.out.println("Folders:");
				for (File folder : folders) {
					System.out.println(folder);
				}

				File[] files = path.listFiles(File::isFile);
				System.out.println("Files:");
				for (File file : files) {
					System.out.println(file);
				}
				
				File[] filesAndFolders = path.listFiles();
				System.out.println("Files and folders:");
				for (File item : filesAndFolders) {
					System.out.println(item);
				}

		Criar pastas e arquivos

			Para criar pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta ou arquivo.

			Para criação de arquivo utilizamos o método "createNewFile()" da classe BufferedWriter.

			Para criação de arquivo utilizamos o método "mkdir()" da classe BufferedWriter.

			Exemplos:

			//Criando arquivo
			String fileName = "NovoArquivo.txt";
			File novoArquivo = new File(folderPath + "\\" + fileName);
			try {
				if (novoArquivo.createNewFile()) {
					System.out.println("Arquivo criado com sucesso!");
				} else {
					System.out.println("Erro na criação do arquivo...");
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		
			// Criando pasta
			String folderName = "NovaPasta";
			File novaPasta = new File(folderPath + "\\" + folderName);
			if (novaPasta.mkdir()) {
				System.out.println("Pasta criada com sucesso!");
			} else {
				System.out.println("Erro na criação da pasta...");
			}

			A pasta ou arquivo será criado somente se não existir nenhum destes itens com o mesmo nome, caso existam eles não são criados, snedo assim não ocorre sobrescrita.

	Métodos para arquivos

		Caso seja instanciado um arquivo com a classe File podemso usar os métodos abaixo para coletar informações.

		getName() - retorna o nome do arquivo
		getParent() - retorna a pasta onde esta o arquivo
		getPath() - retorna o caminho completo do arquivo

- Interfaces

	Interface é um tipo que define um conjunto de operações que uma classe deve implementar, ela estabelece um "contrato" que a classe que a implementar deve cumprir, declarando os métodos pendentes.

	Na interface são declarados somente o cabeçalho dos métodos, a implementação fica a cargo das classes que a implementam.

	Por exemplo:

	interface <nome da interface> {
		...
		<tipo de retorno> <nome do método>();
		...
	}

	interface Shape {
		double area();
		double perimeter();
	}

	Devemos utilizar interfaces para criar sistemas com baixo acoplamento e flexíveis.

- Inversão de controle

	Padrão de desenvolvimento que consiste em retirar da classe a responsabilidade de instanciar suas dependências.

	Por exemplo:

	Consideremos a instanciação de objeto abaixo.

	carRental = new CarRental(pickupDate, returnDate, new Vehicle(carModel));

	Passamos no construtor a instanciação de um objeto como parametro "new Vehicle(carModel)", removendo da classe "CarRental" a necessidade de instanciar o objeto em seu construtor.

- Injeção de dependência

	É uma forma de realizar a inversão de controle: um componente externo instancia a dependência, que é então injetada no objeto "pai". Pode ser implementada de várias formas:

	Construtor
	Classe de instanciação (builder / factory)
	Container / framework

	Por exemplo:

	Consideremos a instanciação de objeto abaixo.

	carRental = new CarRental(pickupDate, returnDate, new Vehicle(carModel));

	Estamos injetando uma dependencia no construtor com "new Vehicle(carModel)".

- Herdar vs cumprir contrato

	Aspectos em comum entre herança e interfaces:

	Relação é-um
	Generalização/especialização
	Polimorfismo

	Diferença fundamental:

	Herança > reuso
	Interface > contrato a ser cumprido

- Herança múltipla e o problema do diamante

	A herança múltipla pode gerar o problema do diamante: uma ambiguidade causada pela existência do mesmo método em mais de uma superclasse.

	Herança múltipla não é permitida na maioria das linguagens!

	Herança múltipla não é permitida na linguagem Java.

- Interface Comparable

	Quando queremos ordenar os dados de um objeto tipo lista utilizamos o método "sort" da classe "Collection", por exemplo (Collections.sort(salary);).

	A comparação de variáveis de tipos primitivos é feita normalmente pois variaveis deste tipo possuem o valor real dentro delas e possuem somente um valor.

	Porém para comparar objetos nao podemos utilizar o método "sort" padrão pois ele não sabe como comparar os objetos, ja que um objeto pode ter diversos parametros.

	Para comparar objetos precisamos então implementar a interface "Comparable<tipo a ser comparado>", sendo que o tipo a ser comparado normalmente é a mesma classe.

	Exemplo de declaração:

	public class <nome da classe> implements Comparable<nome da classe> {
		...
	}

	public class Employee implements Comparable<Employee> {
		...
	}

	Implementando esta interface teremos de cumprir um contrato sobrescrevendo o método "compareTo".

	Exemplo de declaração:

	@Override
	public int compareTo(<tipo a ser comparado> <nome do parametro>) {
		return <variavel a ser comparada>.compareTo(nome do parametro.get<parametro ser comparado>());
	}

	@Override
	public int compareTo(Employee other) {
		return name.compareTo(other.getName());
	}

	Este método recebe como parametro o objeto a ser comparado com o objeto atual, e retorna um  número inteiro negativo, zero ou um inteiro positivo, sendo esse objeto menor, igual ou maior que o objeto comparado.

- Default methods

	A partir do Java 8, interfaces podem conter métodos concretos.

	A intenção básica é prover implementação padrão para métodos, de modo a evitar:

	Repetição de implementação em toda classe que implemente a interface
	A necessidade de se criar classes abstratas para prover reuso da implementação

	Outras vantagens:

	Manter a retrocompatibilidade com sistemas existentes
	Permitir que "interfaces funcionais" (que devem conter apenas um método) possam prover outras operações padrão reutilizáveis

	Considerações importantes:

	Agora as interfaces podem prover reuso
	Agora temos uma forma de herança múltipla, mas o compilador reclama se houver mais de um método com a mesma assinatura, obrigando a sobrescreve-lo

	Interfaces ainda são bem diferentes de classes abstratas. Interfaces não possuem recursos tais como construtores e atributos.

	Declaração:

	Dentro da interface declarar o método completo ao inves de sua assinatura somente, exemplo:

	Antes:

		package model.interfaces;

		public interface InterestService {

			Double getInterestRate();
			Double payment(Double amount, Integer months);
			
		}

	Depois:

		package model.interfaces;

		public interface InterestService {

			Double getInterestRate();
			
			default Double payment(Double amount, Integer months) {
				return amount * Math.pow((1 + getInterestRate() / 100), months);
			}
			
		}

	Um cuidado a ser tomado é que o método não pode usar nenhum tipo de variavel que seja de outra classe pois ele nao tem acesso, caso precise devemos utilizar declarar o método "get" na interface e sobrescrever na classe, conforme o exemplo.

- Generics

	Generics permitem que classes, interfaces e métodos possam ser parametrizados por tipo, desta forma podemos ter classes que trabalham com mais de um tipo, reduzindo a quantida de código no projeto.

	Seus benefícios são:

	Reuso
	Type safety
	Performance

	O uso mais comum de generics é em listas.

	Declaração de classe:

		<modificador de acesso> class <nome da classe><T> {
			...
		}

		Em seguida em todo lugar que o parametro deve ser utilizado colocamos a letra "T".

		Exemplo:

		public class PrintService<T> {

			private List<T> list = new ArrayList<>();
			
			public void addValue(T value) {
				list.add(value);
			}
			
			public T first() {
				return list.get(0);
			}
			
		}

	Declaração de classe com multiplos parametros de tipos genéricos:

		Podemos utilizar a quantidade que quisermos de tipo generico, basta adicionar na declaração da classe separando por virgula, por exemplo:

		<modificador de acesso> class <nome da classe><T, V> {
			...
		}

	Declaração de método:

		<modificador de acesso> <T> <tipo de retorno> <nome do método> (T <parametros>...) {
			...
		}

		Inserimos "<T>" quando a classe não é declarada com tipo generico e sim padrão.

	Declaração de método com mais de um tipo (multiplos):

		Podemos utilizar a quantidade que quisermos de tipo generico, basta adicionar na declaração do método separando por virgula.

		<modificador de acesso> <T, V> <tipo de retorno> <nome do método> (T <parametros>, V <parametros>...) {
			...
		}

	Retornando tipos genericos em métodos:

		Basta no tipo de retorno voce colocar a letra do tipo genérico, exemplo:

		<modificador de acesso> <T> <tipo de retorno> <nome do método> (T <parametros>, V <parametros>...) {
			...
		}

		public <T> T first(T item) {
			return item;
		}

- Type Safety (segurança de tipos)

	Type Safety (segurança de tipos) é a qualidade de fazer operações em dados apenas quando a operação faz sentido. Linguagens ditas type safety possuem mecanismos que impedem o código fazer o que pode dar errado por incompatibilidades entre tipos e uso de um tipo onde não pode. Geralmente impede uma compilação finalizar. É a linguagem que obriga o código respeitar os contratos estabelecidos.

	Desta forma não é indicado declarar uma lista "List<object>" pois ela pode aceitar todo tipo de objeto, quebrando o programa na execução.

- Genéricos delimitados (parâmetros de tipo limitado)

	Pode haver momentos em que você deseja restringir os tipos que podem ser usados como argumentos de tipo em um tipo parametrizado. Por exemplo, um método que opera em números pode querer apenas aceitar instâncias de Number suas subclasses ou aceitar instâncias de Number suas superclasses. É para isso que servem os parâmetros de tipo limitado.

	Para declarar um parâmetro de tipo limitado em subclasses, liste o nome do parâmetro de tipo, seguido pela palavra "extends", seguida por seu limite superior , que neste exemplo é Number.

	Exemplo:

		public <T extends Number> void inspect(T t){
			...
    	}

    Para declarar um parâmetro de tipo limitado em superclasses, liste o nome do parâmetro de tipo, seguido pela palavra "super", seguida por seu limite inferior , que neste exemplo é Number.

	Exemplo:

		public <T super Number> void inspect(T t){
			...
    	}

    Podemos delimitar por mais de um tipo utilizando o "&" na declaração da classe.

    Exemplo:

		public <T extends Number & Serializable> void inspect(T t){
			...
    	}

- Tipos coringa (wildcard types)

	O caractere de interrogação "?" é utilizado como coringa no caso de não soubermos o tipo a ser utilizado.

	Exemplo:

	List<Object> não é o supertipo de qualquer tipo de lista, por exemplo:

	List<Object> myObjs = new ArrayList<Object>();
	List<Integer> myNumbers = new ArrayList<Integer>();
	myObjs = myNumbers; // Erro de compilação

	O supertipo de qualquer tipo de lista é List<?> , este "?" é um tipo coringa, por exemplo:

	List<?> myObjs = new ArrayList<Object>();
	List<Integer> myNumbers = new ArrayList<Integer>();
	myObjs = myNumbers;

	Com tipos coringa podemos fazer métodos que recebem uma lista de tipo genérico, por exemplo:

	public static void printList(List<?> list) {
		...
	}

	Porem não podemos inserir nenhum item em uma lista criada a partir da caractere coringa pois o compilador não sabe se o tipo é compativel, exemplo:

	public static void printList(List<?> list) {
		list.add(3); // Erro de compilação pois não se a lista aceita um inteiro
	}

- Coringas delimitados (bounded wildcards)

	Segue o mesmo principio dos genéricos delimitados porém aplicados ao tipo coringa.

	Para declarar um tipo coringa de tipo limitado por subclasse, coloque o tipo coringa seguido pela palavra "extends", seguida por seu limite superior, por exemplo:

	public static void printList(List<? extends Number> list) {
		...
	}

	Para declarar um tipo coringa de tipo limitado por superclasse, coloque o tipo coringa seguido pela palavra "super", seguida por seu limite inferior, por exemplo:

	public static void printList(List<? super Number> list) {
		...
	}

- Princípio get/put

	Covariância

		É quando a operação de leitura de itens da lista é permitida porém de inserção de itens na lista não é permitida. Isso ocorre ao declarar uma lista de um tipo coringa com delimitador de subclasse, por exemplo:

		List<Integer> intList = new ArrayList<Integer>();
		intList.add(10);
		intList.add(5);

		List<? extends Number> list = intList;

		Number x = list.get(0);

		list.add(20); // Erro de compilacao pois não sabe se o valor que esta tentando adicionar é compativel com o tipo da lista

	Contravariância

		É quando a operação de leitura de itens da lista não é permitida porém de inserção de itens na lista é permitida. Isso ocorre ao declarar uma lista de um tipo coringa com delimitador de superclasse, por exemplo:

		List<Object> myObjs = new ArrayList<Object>();
		myObjs.add("Maria");
		myObjs.add("Alex");

		List<? super Number> myNums = myObjs;

		myNums.add(10);
		myNums.add(3.14);

		Number x = myNums.get(0); // Erro de compilacao pois não sabe se o valor que esta tentando pegar é compativel com o tipo da variavel

- HashCode e Equals

	São operações da classe Object utilizadas para comparar se um objeto é igual a outro.

	equals: lento, resposta 100%
	hashCode: rápido, porém resposta positiva não é 100%

	Tipos comuns (String, Date, Integer, Double, etc.) já possuem a implementação para essas operações. Classes personalizadas precisam sobrepô-las.

	Equals - compara se o objeto é igual a outro, retornando true ou false.

	HashCode - retorna um número inteiro representando um código gerado a partir das informações do objeto, se o hashCode de dois objetos for diferente, então os dois objetos são diferentes, se o hascode for igual dos dois objetos o ideal é validar em seguida com o equal.

	Implementação:

	Todas as IDEs possuem um template de implementação dos métodos equals e hashcode, porem segue abaixo um exemplo:

		Hashcode

		@Override
		public int hashCode() {
			return Objects.hash(<variavel ou variaveis que serão analisadas>);
		}

		@Override
		public int hashCode() {
			return Objects.hash(email, name);
		}

		Equals

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			<tipo> other = (<tipo>) obj;
			return Objects.equals(<variavel ou variaveis que serão analisadas>) && Objects.equals(<variavel ou variaveis que serão analisadas>);
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Client other = (Client) obj;
			return Objects.equals(email, other.email) && Objects.equals(name, other.name);
		}

- Set<T>

	O Set<T> é uma interface genérica que possue diversas implementações para uso, ele representa um conjunto de elementos (similar ao da Álgebra).

	Detalhes:

	Não admite repetições
	Elementos não possuem posição
	Acesso, inserção e remoção de elementos são rápidos
	Oferece operações eficientes de conjunto: interseção, união, diferença.

	Principais implementações:

	HashSet - mais rápido (operações O(1) em tabela hash) e não ordenado
	TreeSet - mais lento (operações O(log(n)) em árvore rubro-negra) e ordenado pelo compareTo do objeto (ou Comparator)
	LinkedHashSet - velocidade intermediária e elementos na ordem em que são adicionados

	Declaração:

	Set<tipo do conjunto> <nome do conjunto> = new <tipo do Set><>();

	Set<String> name = new HashSet<>();
	Set<Integer> salary = new TreehSet<>();
	Set<Product> product = new LinkedHashSet<>();

	Métodos importantes:

	add(obj) - adiciona objeto ao conjunto
	remove(obj) - remove objeto do conjunto
	contains(obj) - verifica se o conjunto contém o objeto baseado em equals e hashCode, se equals e hashCode não existir, é usada comparação de ponteiros
	clear() - esvazia  o conjunto
	size() - mostra o tamanho do conjunto
	removeIf(predicate) - remove do conjunto todos os itens que atendam ao predicado lambda
	addAll(other) - união: adiciona no conjunto os elementos do outro conjunto, sem repetição
	retainAll(other) - interseção: remove do conjunto os elementos não contitos em other
	removeAll(other) - diferença: remove do conjunto os elementos contidos em other

	Como HashSet testa igualdade?

	Se hashCode e equals estiverem implementados: Primeiro hashCode. Se der igual, usa equals para confirmar.
	Se hashCode e equals NÃO estiverem implementados: Compara as referências (ponteiros) dos objetos.

	Como TreeSet testa igualdade?

	É utilizado o método "compareTo" da interface "Comparable", se classe não possuir esta implementação será apresentado erro.

- Map<K,V>

	O Map<K,V> é uma interface genérica que possue diversas implementações para uso, ele representa um conjunto de elementos de pares chave / valor.

	Detalhes:

	Não admite repetições do objeto chave
	Os elementos são indexados pelo objeto chave (não possuem posição)
	Acesso, inserção e remoção de elementos são rápidos

	Principais implementações:

	HashMap - mais rápido (operações O(1) em tabela hash) e não ordenado
	TreeMap - mais lento (operações O(log(n)) em árvore rubro-negra) e ordenado pelo compareTo do objeto (ou Comparator)
	LinkedHashMap - velocidade intermediária e elementos na ordem em que são adicionados

	Declaração:

	Map<<tipo da chave>, <tipo do valor>> <nome do conjunto>  = new <tipo do Map<>();

	Map<Integer, String> name = new HashMap<>();
	Map<Integer, Integer> salary = new TreehMap<>();
	Map<Integer, Product> product = new LinkedHashMap<>();

	Métodos importantes:

	put(key, value) - adiciona objeto ao conjunto
	remove(key) - remove objeto do conjunto
	containsKey(key) - verifica se o conjunto contém o objeto baseado em equals e hashCode, se equals e hashCode não existir, é usada comparação de ponteiros
	get(key) - retirna um objeto do conjunto
	clear() - esvazia  o conjunto
	size() - mostra o tamanho do conjunto
	keySet() - retorna um Set<key>
	values() - retorna um Collection<value>

	Como HashSet testa igualdade?

	Se hashCode e equals estiverem implementados: Primeiro hashCode. Se der igual, usa equals para confirmar.
	Se hashCode e equals NÃO estiverem implementados: Compara as referências (ponteiros) dos objetos.

	Como TreeSet testa igualdade?

	É utilizado o método "compareTo" da interface "Comparable", se classe não possuir esta implementação será apresentado erro.

- Comparator

	Uma ordenação de lista pode ser feita pelo método estatico "Collections.sort(<lista a ser ordenada>);" , porém par aisso devemos implementar a interface "Comparable" nas classes a serem ordenadas.

	Implementar uma interface "Comparable" em uma classe não é recomendado, pois para alterar os parametros de comparação deveremos alterar uma classe ja fechada para alterações, dificultando o processo e gerando possiveis falhas.

	Como solução podemos criar uma classe de comparação que implementa a interface "Comparator" removendo assim a lógica de comparação da classe, mantendo-a fechada.

	Para ordenar a lista podemos então utilizar o método "<lista a ser ordenada>.sort(<comparator>)" do proprio objeto da lista, esse método recebe como argumento um objeto Comparator.

	Temos diversas formas de utilizar o Comparator.

	Comparator objeto de classe separada:

		Para isso criamos uma classe separada que implementa a classe Comparator e sobrescreve o método "compare", exemplo abaixo:

			package application;

			import java.util.Comparator;

			import model.entities.Product;

			public class MyComparator implements Comparator<Product> {

				@Override
				public int compare(Product p1, Product p2) {
					return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
				}

			}

		Em seguida chamamos o método "sort" da lista a ser ordenada passando um objeto da nossa classe Comparator como argumento, exemplo abaixo:

			list.sort(new MyComparator());

	Comparator objeto de classe anônima:

		Ao invés de criarmos uma classe "normal" podemos criar uma classe anônima para otimizar código, exemplo abaixo:

			Comparator<Product> comp = new Comparator<Product>() {
				@Override
				public int compare(Product p1, Product p2) {
					return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
				}
			};

		Ela traz a implementação do Comparator direto na declaração da variável.

		Em seguida chamamos o método "sort" da lista a ser ordenada passando o objeto da nossa classe anônima Comparator como argumento, exemplo abaixo:

			list.sort(comp);

	Comparator objeto de expressão lambda com chaves:

		Para maior otimização, ao invés de utilizar uma classe anônima podemos utilizar um método anônimo no formato de expressão lambda (com chaves), exemplo abaixo:

			Comparator<Product> comp = (p1, p2) -> {
				return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
			};

		No campo dos parênteses temos os argumentos, em seguida temos a flecha (arrow), a abertura de chaves, e por fim o que será executado no método, com a chave de fechamento.

		Em seguida chamamos o método "sort" da lista a ser ordenada passando o objeto da nossa classe anônima Comparator como argumento, exemplo abaixo:

			list.sort(comp);

	Comparator objeto de expressão lambda sem chaves:

		Similar a expressão lambda com chaves, mas para maior otimização ainda, quando temos uma expressão lambda de somente uma linha podemos descartar as chaves de abertura e fechamento e a palavra return, exemplo abaixo:

			Comparator<Product> comp = (p1, p2) -> p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());

		Em seguida chamamos o método "sort" da lista a ser ordenada passando o objeto da nossa classe anônima Comparator como argumento, exemplo abaixo:

			list.sort(comp);

	Comparator expressão lambda "direto no argumento":

		Por fim podemos otimizar de forma maior evitando a declaração da variável e inserindo a expressão lambda direto como argumento do método sorte, exemplo abaixo:

			list.sort((p1, p2) -> p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase()));

- Programação funcional e cálculo lambda

	Temos diversos paradigmas de programação:

	Imperativo (C, Pascal, Fortran, Cobol)
	Orientado a objetos (C++, Object Pascal, Java (< 8), C# (< 3))
	Funcional (Haskell, Closure, Clean, Erlang)
	Lógico (Prolog)
	Multiparadigma (JavaScript, Java (8+), C# (3+), Ruby, Python, Go)

	O paradigma funcional de programação é baseado no formalismo matemático Cálculo Lambda.

	Tabela de comparação dos paradigmas imperativo e funcional:

														Programação Imperativa 					Programação Funcional

	Como se descreve algo a ser computado 				comandos ("como" - imperativa) 			expressões ("o quê" - declarativa)
	Funções possuem transparência referencial 			fraco 									forte
	(ausência de efeitos colaterais)
	Objetos imutáveis 									raro 									comum
	Funções são objetos de primeira ordem 				não 									sim
	Expressividade / código conciso 					baixa 									alta
	Tipagem dinâmica / inferência de tipos 				raro 									comum

	Detalhes

	Transparência referencial - uma função possui transparência referencial se seu resultado for sempre o mesmo para os mesmos dados de entrada. Benefícios: simplicidade e previsibilidade.

	Funções são objetos de primeira ordem (ou primeira classe) - isso significa que funções podem, por exemplo, serem passadas como parâmetros de métodos, bem como retornadas como resultado de métodos.

	Tipagem dinâmica / inferência de tipos - reconhecimento automático de tipos.

	Expressividade / código conciso - código simples, em uma linha somente, bem claro.

- Expressões lambda

	Em programação funcional, expressão lambda corresponde a uma função anônima de primeira classe.

	Exemplo:

	list.sort((p1, p2) -> p1.getPrice().compareTo(p2.getPrice()));

- Interface funcional

	É uma interface que possui um único método abstrato. Suas implementações serão tratadas como expressões lambda.

	Um exemplo é a interface "Comparator".

	Algumas outras interfaces funcionais comuns:

	Predicate
	Function
	Consumer

- Predicate (exemplo com removeIf)

	Interface funcional com o método abstrato abaixo:

	public interface Predicate<T> {
		boolean test (T t);
	}

	Serve para testar algo e devolver um booleano.

	Pode ser implementada de diversas formas:

	Implementação da interface

		Criar uma classe separada que implementa a interface Predicate e declarar o método abstrato conforme exemplo abaixo:

			public class ProductPredicate implements Predicate<Product> {
				@Override
				public boolean test(Product p) {
					return p.getPrice() >= 100.0;
				}
			}

		Para utilizar instanciamos um objeto desta classe e passamos como argumento para o método RemoveIf conforme exemplo abaixo:

			list.removeIf(new ProductPredicate());

	Reference method com método estático

		Não criar a classe separada e sim um método estatico na classe alvo conforme exemplo abaixo:

			public static boolean staticProductPredicate(Product p) {
				return p.getPrice() >= 100.0;
			}

		Para utilizar chamamos o método da classe diretamente no parametro do método RemoveIf conforme exemplo abaixo:

			list.removeIf(Product::staticProductPredicate);

	Reference method com método não estático

		Não criar a classe separada e sim um método não estatico na classe alvo conforme exemplo abaixo:

			public boolean nonStaticProductPredicate() {
				return price >= 100.0;
			}

		Para utilizar chamamos o método da classe diretamente no parametro do método RemoveIf conforme exemplo abaixo:

			list.removeIf(Product::nonStaticProductPredicate)

	Expressão lambda declarada

		Criar uma variavel Predicate com a expressão lambda conforme exemplo abaixo:

			Predicate<Product> pred = p -> p.getPrice() >= 100.0;

		Para utilizar passamos essa variavel criada como parametro do método RemoveIf conforme exemplo abaixo:

			list.removeIf(pred);

	Expressão lambda inline

		Podemos passar diretamente a exmpressão lambda como parametro do método RemoveIf conforme exemplo abaixo:

			list.removeIf(p -> p.getPrice() >= 100.0);

- Consumer (exemplo com forEach)

	Interface funcional com o método abstrato abaixo:

	public interface Consumer<T> {
		void accept(T t);
	}

	Serve para executar uma ação e não retornar nada.

	Pode ser implementada de diversas formas, todas similares ao Predicate:

	Implementação da interface
	Reference method com método estático
	Reference method com método não estático
	Expressão lambda declarada
	Expressão lambda inline

